# pages/1_Screener.py
from __future__ import annotations

import io
import time
from datetime import datetime, timedelta
from typing import Dict, List
import json
import sys
import os

import numpy as np
import pandas as pd
import streamlit as st
import plotly.graph_objects as go

# d√πng module adapter m·ªõi (singular)
from pick_best_by_symbols import VnAdapter, ScoreWeights, score_symbols, _calc_adtv_vnd

# Add utils to path
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

try:
    from utils.theme import set_page_config, apply_theme
    from utils.styling import load_css, create_section_header, create_metric_card
except ImportError:
    def set_page_config(title, icon):
        st.set_page_config(page_title=title, page_icon=icon, layout="wide")
    def apply_theme():
        pass
    def load_css():
        pass
    def create_section_header(title):
        return f"<h3>{title}</h3>"
    def create_metric_card(title, value, subtitle="", color="#2a5298"):
        return f"<div><h4>{title}</h4><h2>{value}</h2><small>{subtitle}</small></div>"

# ===== Optional deps for LLM & news =====
try:
    from openai import OpenAI
    _OPENAI_OK = True
except Exception:
    OpenAI = None
    _OPENAI_OK = False

try:
    import requests
except Exception:
    requests = None

# =========================
# Page config & Styling
# =========================
set_page_config("üìä Stock Screener", "üìä")
apply_theme()
load_css()

st.markdown("""
<div class="main-title">
    <h1 style="color: white !important; text-shadow: 0 2px 4px rgba(0,0,0,0.3);">üìä Stock Screener</h1>
    <p style="color: white !important; text-shadow: 0 1px 3px rgba(0,0,0,0.3);">C√¥ng c·ª• s√†ng l·ªçc v√† ch·∫•m ƒëi·ªÉm c·ªï phi·∫øu chuy√™n nghi·ªáp</p>
</div>
""", unsafe_allow_html=True)

# =========================
# Helpers
# =========================
def _prev_weekday(dt: datetime) -> datetime:
    while dt.weekday() >= 5:
        dt -= timedelta(days=1)
    return dt

def _parse_symbols_input(raw: str) -> List[str]:
    seen, out = set(), []
    for p in [x.strip().upper() for x in raw.split(",") if x.strip()]:
        if p not in seen:
            seen.add(p); out.append(p)
    return out

def _filter_company_tickers_only(symbols: List[str]) -> List[str]:
    """Ch·ªâ gi·ªØ m√£ 3 k√Ω t·ª± ch·ªØ c√°i (VD: FPT, VNM, HPG). Lo·∫°i ETF/CW/CCQ."""
    return [s for s in (symbols or []) if len(s) == 3 and s.isalpha()]

@st.cache_data(show_spinner=False, ttl=60*45)
def _get_quote_history_cached(symbol: str, days: int, end_date: str, sources: List[str]) -> pd.DataFrame:
    adapter = VnAdapter(preferred_sources=sources, end_date=end_date, verbose=False)
    return adapter.get_quote_history(symbol, days=days)

@st.cache_data(show_spinner=False, ttl=60*60)
def _get_screener_snapshot_cached(source: str = "TCBS") -> pd.DataFrame:
    """
    D√πng vnstock.Screener (n·∫øu c√≥) ch·ªâ ƒë·ªÉ l·∫•y sector ph·ª•c v·ª• sector-neutral scoring.
    Kh√¥ng d√πng c√°c s·ªë li·ªáu PE/PB/ROE‚Ä¶ ·ªü ƒë√¢y cho k·∫øt qu·∫£ ch√≠nh (ƒë√£ l·∫•y qua adapter.get_fundamentals).
    """
    try:
        adapter = VnAdapter(preferred_sources=[source], end_date=None, verbose=False)
        v = adapter.v
        Scr = getattr(v, "Screener", None)
        if Scr is None:
            return pd.DataFrame()
        scr = Scr(source=source)
        for meth in ("snapshot", "overview"):
            if hasattr(scr, meth):
                df = getattr(scr, meth)()
                if isinstance(df, pd.DataFrame) and not df.empty:
                    df.columns = [str(c).strip() for c in df.columns]
                    return df
    except Exception:
        pass
    return pd.DataFrame()

def _extract_sector_map_from_snapshot(snapshot_df: pd.DataFrame) -> Dict[str, str]:
    """Tr·∫£ v·ªÅ dict { 'FPT': 'Technology', ... } n·∫øu snapshot c√≥ c·ªôt ng√†nh."""
    if snapshot_df is None or snapshot_df.empty:
        return {}
    low = {c.lower(): c for c in snapshot_df.columns}
    sym_col = None
    for k in ("ticker", "symbol", "code"):
        if k in low:
            sym_col = low[k]; break
    if sym_col is None:
        return {}
    sector_col = None
    for k in ("sector", "industry", "icb_name", "industry_name", "sector_name"):
        if k in low:
            sector_col = low[k]; break
    if sector_col is None:
        return {}
    out = {}
    for _, r in snapshot_df.iterrows():
        sym = str(r[sym_col]).strip().upper()
        sec = str(r.get(sector_col, "")).strip()
        if sym and sec:
            out[sym] = sec
    return out

@st.cache_data(show_spinner=False, ttl=60*60)
def _get_fundamentals_precise_cached(symbol: str, source: str = "TCBS", period: str = "quarter") -> Dict[str, float]:
    """
    L·∫•y fundamentals qua adapter.get_fundamentals:
      - PE/PB/ROE/... t·ª´ finance.ratio(period)
      - rev_yoy t·ª´ **TCBS API** (yearRevenueGrowth, qu√Ω m·ªõi nh·∫•t)
      - C√°c tr∆∞·ªùng d·∫°ng % ƒë√£ ƒë∆∞·ª£c chu·∫©n ho√° th√†nh ƒë∆°n v·ªã ph·∫ßn trƒÉm trong adapter.
    """
    try:
        adapter = VnAdapter(preferred_sources=[source], end_date=None, verbose=False)
        return adapter.get_fundamentals(symbol, period=period)
    except Exception:
        return {}

def _annualized_vol(returns: pd.Series):
    d = returns.dropna()
    return d.std(ddof=0) * (252 ** 0.5) if len(d) > 1 else np.nan

def _safe_pct(a, b):
    try:
        if b == 0 or pd.isna(b): return np.nan
        return (float(a) - float(b)) / abs(float(b))
    except Exception:
        return np.nan

def compute_features_local_from_px(px: pd.DataFrame, fund: Dict) -> Dict:
    """T√≠nh m1/m3/m6, ADTV(20) t·ª´ d·ªØ li·ªáu gi√°; gh√©p th√™m fundamentals ƒë√£ chu·∫©n ho√° t·ª´ adapter."""
    if px is None or px.empty:
        base = {"m1": np.nan, "m3": np.nan, "m6": np.nan, "adtv": np.nan, "vol": np.nan}
        base.update(fund or {})
        return base

    p = px.copy()
    p["date"] = pd.to_datetime(p["date"])
    p = p.sort_values("date")

    def pct_change(days_back):
        if len(p) < days_back + 1: return np.nan
        return _safe_pct(p["close"].iloc[-1], p["close"].iloc[-(days_back + 1)])

    m1 = pct_change(21)
    m3 = pct_change(63)
    m6 = pct_change(126)

    # T√≠nh ADTV tr·ª±c ti·∫øp t·ª´ d·ªØ li·ªáu l·ªãch s·ª≠ (t·ªët h∆°n)
    adtv = _calc_adtv_from_history(p, n=20)
    vol = _annualized_vol(p["close"].pct_change())

    out = {"m1": m1, "m3": m3, "m6": m6, "adtv": adtv, "vol": vol}
    out.update(fund or {})
    return out

def _calc_adtv_from_history(px: pd.DataFrame, n: int = 20) -> float:
    """T√≠nh ADTV t·ª´ d·ªØ li·ªáu l·ªãch s·ª≠ gi√° c·∫£i ti·∫øn."""
    if px is None or px.empty:
        return np.nan
    
    # ƒê·∫£m b·∫£o c√≥ ƒë·ªß c·ªôt c·∫ßn thi·∫øt
    available_cols = set(px.columns)
    required_cols = {"close", "volume"}
    
    if not required_cols.issubset(available_cols):
        return np.nan
    
    # L·∫•y n phi√™n g·∫ßn nh·∫•t v√† l√†m s·∫°ch d·ªØ li·ªáu
    data = px.tail(n).copy()
    data["close_clean"] = pd.to_numeric(data["close"], errors="coerce")
    data["volume_clean"] = pd.to_numeric(data["volume"], errors="coerce")
    
    # Lo·∫°i b·ªè c√°c ng√†y c√≥ volume = 0 ho·∫∑c NaN (kh√¥ng giao d·ªãch)
    valid_data = data.dropna(subset=["close_clean", "volume_clean"])
    valid_data = valid_data[valid_data["volume_clean"] > 0]
    
    if len(valid_data) < 5:  # C·∫ßn √≠t nh·∫•t 5 phi√™n c√≥ giao d·ªãch
        return np.nan
    
    # T√≠nh gi√° tr·ªã giao d·ªãch trung b√¨nh
    # Gi√° t·ª´ vnstock: 41.10 ‚Üí 41,100 VND (nh√¢n 1000)
    # Volume: ƒë√£ ƒë√∫ng ƒë∆°n v·ªã (s·ªë c·ªï phi·∫øu)
    daily_value = valid_data["close_clean"] * 1000 * valid_data["volume_clean"]
    adtv = float(daily_value.mean())
    
    return adtv if not np.isnan(adtv) and adtv > 0 else np.nan

def _missing_bdays_to_break(dates: pd.Series) -> List[pd.Timestamp]:
    if dates.empty:
        return []
    d0 = pd.to_datetime(dates).sort_values()
    start = d0.min().normalize()
    end = d0.max().normalize()
    all_bdays = pd.bdate_range(start, end, freq="B")
    present = pd.to_datetime(d0.dt.normalize().unique())
    present_set = set(present)
    return [d for d in all_bdays if d not in present_set]

def _company_name_from_snapshot(snapshot_df: pd.DataFrame, symbol: str) -> str:
    if snapshot_df is None or snapshot_df.empty:
        return "‚Äî"
    low = {c.lower(): c for c in snapshot_df.columns}
    sym_col = None
    for k in ("ticker", "symbol", "code"):
        if k in low:
            sym_col = low[k]; break
    if sym_col is None:
        return "‚Äî"
    row = snapshot_df[sym_col].astype(str).str.upper() == symbol.upper()
    hit = snapshot_df[row]
    if hit.empty:
        return "‚Äî"
    name_candidates = [
        "organ_short_name", "organ_short_nm", "organ_name", "organname",
        "company_name", "companyName", "name", "org_name", "short_name"
    ]
    for cand in name_candidates:
        col = low.get(cand.lower())
        if col and col in hit.columns:
            val = str(hit.iloc[0][col]).strip()
            if val:
                return val
    return "‚Äî"

def make_ohlcv_figure(
    px: pd.DataFrame,
    title: str,
    *,
    default_months_view: int = 3,
    right_pad_months: int = 2,
    height: int = 700,
    vol_frac: float = 0.18,
    gap: float = 0.02,
    show_ma9: bool = True,
    show_ma20: bool = True,
    show_ma50: bool = False,
    show_ma200: bool = False,
    show_bollinger: bool = True,
) -> go.Figure:
    df = px.copy()
    df["date"] = pd.to_datetime(df["date"]); df = df.sort_values("date")
    missing_vals = _missing_bdays_to_break(df["date"])

    UP, DOWN = "#26a69a", "#ef5350"
    UP_A, DOWN_A = "rgba(38,166,154,0.85)", "rgba(239,83,80,0.85)"

    # T√≠nh to√°n SMA
    if show_ma9:
        df["ma9"] = df["close"].rolling(9, min_periods=1).mean()
    if show_ma20:
        df["ma20"] = df["close"].rolling(20, min_periods=1).mean()
    if show_ma50:
        df["ma50"] = df["close"].rolling(50, min_periods=1).mean()
    if show_ma200:
        df["ma200"] = df["close"].rolling(200, min_periods=1).mean()
        
    # T√≠nh to√°n Bollinger Bands
    if show_bollinger:
        bb_period = 20
        bb_multiplier = 2
        df["bb_middle"] = df["close"].rolling(bb_period, min_periods=1).mean()
        bb_std = df["close"].rolling(bb_period, min_periods=1).std()
        df["bb_upper"] = df["bb_middle"] + (bb_std * bb_multiplier)
        df["bb_lower"] = df["bb_middle"] - (bb_std * bb_multiplier)

    fig = go.Figure()
    
    # Th√™m Bollinger Bands tr∆∞·ªõc ƒë·ªÉ hi·ªÉn th·ªã ·ªü ph√≠a sau
    if show_bollinger:
        fig.add_trace(go.Scatter(
            x=df["date"], y=df["bb_upper"], 
            mode="lines", name="BB Upper",
            line=dict(color="rgba(156, 163, 175, 0.3)", width=1, dash="dash"),
            showlegend=False
        ))
        fig.add_trace(go.Scatter(
            x=df["date"], y=df["bb_lower"], 
            mode="lines", name="BB Lower",
            line=dict(color="rgba(156, 163, 175, 0.3)", width=1, dash="dash"),
            fill="tonexty", fillcolor="rgba(156, 163, 175, 0.1)",
            showlegend=False
        ))
    
    # Th√™m candlestick chart
    fig.add_trace(go.Candlestick(
        x=df["date"], open=df["open"], high=df["high"], low=df["low"], close=df["close"],
        name="Gi√°",
        increasing=dict(line=dict(color=UP, width=1), fillcolor=UP),
        decreasing=dict(line=dict(color=DOWN, width=1), fillcolor=DOWN),
        whiskerwidth=0,
        showlegend=True
    ))
    
    # Th√™m c√°c ƒë∆∞·ªùng SMA
    if show_ma9:
        fig.add_trace(go.Scatter(x=df["date"], y=df["ma9"], mode="lines", name="SMA9",
                                 line=dict(color="#f97316", width=1.2), showlegend=True))
    if show_ma20:
        fig.add_trace(go.Scatter(x=df["date"], y=df["ma20"], mode="lines", name="SMA20",
                                 line=dict(color="#f59e0b", width=1.4), showlegend=True))
    if show_ma50:
        fig.add_trace(go.Scatter(x=df["date"], y=df["ma50"], mode="lines", name="SMA50",
                                 line=dict(color="#60a5fa", width=1.4), showlegend=True))
    if show_ma200:
        fig.add_trace(go.Scatter(x=df["date"], y=df["ma200"], mode="lines", name="SMA200",
                                 line=dict(color="#a78bfa", width=1.6), showlegend=True))
    
    # Th√™m ƒë∆∞·ªùng Bollinger Middle (ch√≠nh l√† SMA20)
    if show_bollinger:
        fig.add_trace(go.Scatter(x=df["date"], y=df["bb_middle"], mode="lines", name="BB Middle",
                                 line=dict(color="#9ca3af", width=1.0, dash="dot"), showlegend=True))

    up = (df["close"] >= df["open"]).fillna(False)
    fig.add_trace(go.Bar(
        x=df["date"], y=df["volume"].fillna(0), name="Kh·ªëi l∆∞·ª£ng",
        marker_color=np.where(up, UP_A, DOWN_A), marker_line_width=0, opacity=0.95,
        yaxis="y2", showlegend=True
    ))

    x_end = df["date"].max()
    x_pad = x_end + pd.DateOffset(months=int(right_pad_months))
    x_start = x_end - pd.DateOffset(months=int(default_months_view))

    v = pd.to_numeric(df["volume"], errors="coerce").dropna()
    y2_max = None
    if len(v) > 0:
        q995 = float(np.percentile(v, 99.5)); med = float(np.median(v))
        y2_max = max(q995, med*3.0) * 1.10

    grid, axis, font = "#1f2937", "#374151", "#e5e7eb"
    paper = "#0b1220"; plot = "#0b1220"

    fig.update_layout(
        xaxis=dict(
            range=[x_start, x_pad],
            rangebreaks=[dict(bounds=["sat","mon"]), dict(values=missing_vals)],
            rangeslider=dict(visible=True, range=[df["date"].min(), x_pad],
                             thickness=0.12, bgcolor="#0f172a", bordercolor="#334155"),
            rangeselector=dict(
                y=0, yanchor="bottom", x=0.5, xanchor="center",
                bgcolor="#0b1220", activecolor="#1f2a44",
                buttons=[
                    dict(count=1, label="1M", step="month", stepmode="backward"),
                    dict(count=3, label="3M", step="month", stepmode="backward"),
                    dict(count=6, label="6M", step="month", stepmode="backward"),
                    dict(step="all", label="All")
                ],
            ),
            ticklabelposition="outside",
            showline=True, linewidth=1, linecolor=axis, gridcolor=grid, zeroline=False
        ),
        yaxis=dict(
            domain=[vol_frac + gap, 1.0],
            autorange=True,  # T·ª± ƒë·ªông scale theo d·ªØ li·ªáu hi·ªÉn th·ªã
            fixedrange=False,  # Cho ph√©p zoom/pan tr·ª•c Y
            showline=True, linewidth=1, linecolor=axis, gridcolor=grid, zeroline=False
        ),
        yaxis2=dict(
            domain=[0.0, vol_frac],
            rangemode="tozero", 
            autorange=True,  # T·ª± ƒë·ªông scale cho tr·ª•c volume
            fixedrange=False,  # Cho ph√©p zoom/pan tr·ª•c Y volume 
            tickformat="~s",
            showline=True, linewidth=1, linecolor=axis, gridcolor=grid, zeroline=False
        ),
        legend=dict(
            x=0.995, y=0.995, xanchor="right", yanchor="top",
            bgcolor="rgba(15,23,42,0.65)", bordercolor="#334155", borderwidth=1,
            font=dict(color=font, size=11),
            orientation="v",
            itemsizing="constant",
        ),
        title=dict(text=title, x=0.5, xanchor="center", font=dict(color="#ffffff", size=16)),
        hovermode="x unified",
        bargap=0.12, bargroupgap=0.0,
        margin=dict(l=6, r=6, t=52, b=10),
        paper_bgcolor=paper, plot_bgcolor=plot,
        font=dict(color=font),
        hoverlabel=dict(bgcolor="#0f172a", font_color=font, bordercolor=axis),
        height=height,
        # Th√™m c·∫•u h√¨nh ƒë·ªÉ t·ªëi ∆∞u h√≥a t∆∞∆°ng t√°c
        dragmode="zoom",  # Cho ph√©p zoom khi k√©o
        selectdirection="h",  # Ch·ªâ zoom theo chi·ªÅu ngang (h = horizontal)
        # Th√™m scroll zoom ƒë·ªÉ c√≥ th·ªÉ zoom b·∫±ng cu·ªôn chu·ªôt
        xaxis_fixedrange=False,  # Cho ph√©p zoom tr·ª•c X
        yaxis_fixedrange=False   # Cho ph√©p zoom tr·ª•c Y
    )
    
    return fig


# ======== TCBS Activities News helpers ========
@st.cache_data(show_spinner=False, ttl=600)
def fetch_activity_news_raw(symbol: str, page: int = 0, size: int = 100) -> Dict:
    """G·ªçi API TCBS activities ƒë·ªÉ l·∫•y danh s√°ch c√¥ng b·ªë/ho·∫°t ƒë·ªông theo m√£."""
    if requests is None:
        return {}
    url = "https://apipubaws.tcbs.com.vn/tcanalysis/v1/news/activities"
    params = {"fData": symbol, "fType": "tickers", "page": int(page), "size": int(size)}
    headers = {"User-Agent": "Mozilla/5.0 (compatible; StockApp/1.0)"}
    try:
        r = requests.get(url, params=params, headers=headers, timeout=10)
        r.raise_for_status()
        return r.json()
    except Exception:
        return {}

def filter_recent_activity_news(payload: Dict, recent_days: int = 7) -> List[Dict]:
    """L·ªçc danh s√°ch news, ch·ªâ l·∫•y trong v√≤ng `recent_days` g·∫ßn nh·∫•t."""
    items = (payload or {}).get("listActivityNews", []) or []
    cutoff = pd.Timestamp.today() - pd.Timedelta(days=int(recent_days))
    out: List[Dict] = []
    for it in items:
        try:
            ts = pd.to_datetime(it.get("publishDate"), errors="coerce")
        except Exception:
            ts = pd.NaT
        if pd.isna(ts):
            continue
        if ts >= cutoff:
            out.append({
                "ticker": it.get("ticker"),
                "title": (it.get("title") or "").strip(),
                "source": it.get("source"),
                "published_at": ts,
            })
    out.sort(key=lambda x: x["published_at"], reverse=True)
    return out


# ======== Indicators / stats for FORM ========
def _rsi(series: pd.Series, n: int = 14) -> pd.Series:
    s = series.astype(float)
    delta = s.diff()
    up = delta.clip(lower=0).rolling(n).mean()
    down = (-delta.clip(upper=0)).rolling(n).mean()
    rs = up / down.replace(0, np.nan)
    return 100 - (100 / (1 + rs))

def _atr_df(df: pd.DataFrame, n: int = 14) -> pd.Series:
    d = df.copy()
    d["prev_close"] = d["close"].shift(1)
    tr = pd.concat([
        (d["high"] - d["low"]).abs(),
        (d["high"] - d["prev_close"]).abs(),
        (d["low"]  - d["prev_close"]).abs()
    ], axis=1).max(axis=1)
    return tr.rolling(n).mean()

def _slope(arr: pd.Series, lookback: int = 5) -> float:
    y = pd.to_numeric(arr.tail(lookback), errors="coerce").dropna()
    if len(y) < 3:
        return np.nan
    x = np.arange(len(y), dtype=float)
    A = np.vstack([x, np.ones(len(x))]).T
    m, _ = np.linalg.lstsq(A, y, rcond=None)[0]
    return float(m)

def _pivot_levels(df: pd.DataFrame, win_high: int = 20, win_low: int = 20):
    d = df.copy().tail(max(win_high, win_low) + 5)
    res = float(d["high"].rolling(win_high, min_periods=1).max().iloc[-2])
    sup = float(d["low"].rolling(win_low, min_periods=1).min().iloc[-2])
    return res, sup

def build_structured_stats(px: pd.DataFrame) -> dict:
    p = px.copy()
    p["date"] = pd.to_datetime(p["date"])
    p = p.sort_values("date").reset_index(drop=True)

    last_close = float(p["close"].iloc[-1])
    last_date  = p["date"].iloc[-1].strftime("%Y-%m-%d")

    # Ch·ªâ MA20/50/200
    for w in (20, 50, 200):
        p[f"ma{w}"] = p["close"].rolling(w).mean()

    def rr(days):
        return float((p["close"].iloc[-1] / p["close"].iloc[max(0, len(p)-1-days)] - 1) * 100) if len(p) > days else np.nan
    r1m, r3m, r6m = rr(21), rr(63), rr(126)

    rsi14 = float(_rsi(p["close"], 14).iloc[-1])
    atr14 = _atr_df(p, 14).iloc[-1]
    atr_pct = float((atr14 / last_close) * 100) if pd.notna(atr14) else np.nan
    adtv_vnd = float((p["close"].tail(20) * 1000 * p["volume"].tail(20)).mean()) if "volume" in p else np.nan

    win = min(252, len(p))
    hi_52w = float(p["high"].tail(win).max())
    lo_52w = float(p["low"].tail(win).min())

    slope_ma20  = _slope(p["ma20"], 5)
    slope_ma50  = _slope(p["ma50"], 5)
    slope_ma200 = _slope(p["ma200"], 10)

    vol_mean_20 = float(p["volume"].tail(20).mean())
    vol_mean_60 = float(p["volume"].tail(60).mean())
    vol_trend = "tƒÉng" if vol_mean_20 > vol_mean_60 * 1.1 else ("gi·∫£m" if vol_mean_20 < vol_mean_60 * 0.9 else "ƒëi ngang")

    res_piv, sup_piv = _pivot_levels(p, 20, 20)
    levels = {
        "kh√°ng_c·ª±_g·∫ßn": res_piv,
        "h·ªó_tr·ª£_g·∫ßn": sup_piv,
        "ma20": float(p["ma20"].iloc[-1]) if not pd.isna(p["ma20"].iloc[-1]) else np.nan,
        "ma50": float(p["ma50"].iloc[-1]) if not pd.isna(p["ma50"].iloc[-1]) else np.nan,
        "ma200": float(p["ma200"].iloc[-1]) if not pd.isna(p["ma200"].iloc[-1]) else np.nan,
        "hi_52w": hi_52w, "lo_52w": lo_52w
    }

    return {
        "last_date": last_date, "last_close": last_close,
        "ret_1m_%": r1m, "ret_3m_%": r3m, "ret_6m_%": r6m,
        "rsi14": rsi14, "atr14_%": atr_pct,
        "adtv_20_vnd": adtv_vnd,
        "slopes": {"ma20": slope_ma20, "ma50": slope_ma50, "ma200": slope_ma200},
        "levels": levels,
        "vol_trend": vol_trend
    }

def auto_generate_report_if_possible(symbol: str, tech_stats: dict, llm_model: str, company_name: str = None) -> bool:
    """
    T·ª± ƒë·ªông t·∫°o b√°o c√°o n·∫øu c√≥ API key v√† ch∆∞a c√≥ b√°o c√°o cho symbol n√†y.
    Returns True n·∫øu ƒë√£ t·∫°o b√°o c√°o th√†nh c√¥ng.
    """
    key = st.session_state.get("openai_api_key", "") or ""
    if not key or not _OPENAI_OK:
        return False
    
    # Ki·ªÉm tra n·∫øu ƒë√£ c√≥ b√°o c√°o cho symbol n√†y r·ªìi
    existing_report = (st.session_state.get("form_cache") or {}).get(symbol)
    if existing_report:
        return True
    
    try:
        model = llm_model or "gpt-4o-mini"
        template = st.session_state.get("analysis_template", "")
        prompt = st.session_state.get("analysis_prompt", "")
        system_prompt = st.session_state.get("system_prompt", "")
        
        with st.spinner(f"ü§ñ ƒêang t·ª± ƒë·ªông ph√¢n t√≠ch {symbol}..."):
            report = call_llm_structured_report(
                key, model, symbol, tech_stats,
                template=template, prompt=prompt, system_prompt=system_prompt, company_name=company_name
            )
            
        st.session_state.setdefault("form_cache", {})[symbol] = report
        return True
    except Exception as e:
        st.error(f"‚ùå L·ªói t·ª± ƒë·ªông t·∫°o b√°o c√°o cho {symbol}: {e}")
        return False

def call_llm_structured_report(api_key: str, model: str, symbol: str, tech_stats: dict, 
                              template: str = None, prompt: str = None, system_prompt: str = None, company_name: str = None) -> str:
    if not _OPENAI_OK or not api_key:
        return "‚õî Ch∆∞a c·∫•u h√¨nh OpenAI API key."

    # S·ª≠ d·ª•ng template t·ª´ tham s·ªë ho·∫∑c m·∫∑c ƒë·ªãnh
    default_template = (
        "üìä PH√ÇN T√çCH K·ª∏ THU·∫¨T - {symbol}\n\n"
        "PH√ÇN T√çCH K·ª∏ THU·∫¨T\n\n"
        "1. Xu h∆∞·ªõng gi√°:\n- ...\n- ...\n- ...\n\n"
        "2. ƒê∆∞·ªùng MA (20/50/200):\n- MA20: ...\n- MA50: ...\n- MA200: ...\n\n"
        "3. Kh·ªëi l∆∞·ª£ng:\n- ...\n- ...\n\n"
        "4. H·ªó tr·ª£ & Kh√°ng c·ª±:\n- Kh√°ng c·ª±: ...\n- H·ªó tr·ª£ g·∫ßn: ...\n- H·ªó tr·ª£ s√¢u: ...\n\n"
        "NH·∫¨N ƒê·ªäNH NHANH & CHI·∫æN L∆Ø·ª¢C\n\n"
        "- Ng·∫Øn h·∫°n: ...\n- Trung h·∫°n: ...\n\n"
        "Chi·∫øn l∆∞·ª£c:\n- L∆∞·ªõt s√≥ng: ...\n- Trung h·∫°n: ..."
    )
    
    used_template = template or default_template
    
    # Format template v·ªõi symbol v√† company name
    display_company_name = company_name or "‚Äî"
    formatted_template = used_template.format(symbol=symbol, company_name=display_company_name)
    
    # S·ª≠ d·ª•ng prompt t·ª´ tham s·ªë ho·∫∑c m·∫∑c ƒë·ªãnh
    default_prompt = (
        "B·∫°n l√† chuy√™n gia PTKT c·ªï phi·∫øu Vi·ªát Nam. D·ª±a **duy nh·∫•t** v√†o d·ªØ li·ªáu cung c·∫•p, "
        "h√£y vi·∫øt b√°o c√°o ƒë√∫ng **form m·∫´u** (ti·∫øng Vi·ªát, ng·∫Øn g·ªçn). Ch·ªâ ƒë√°nh gi√° MA20/MA50/MA200.\n\n"
        "TEMPLATE:\n{template}\n\n"
        "H∆Ø·ªöNG D·∫™N:\n"
        "- B·∫Øt ƒë·∫ßu b√°o c√°o b·∫±ng header c√≥ m√£ c·ªï phi·∫øu v√† t√™n c√¥ng ty nh∆∞ trong template.\n"
        "- 'ƒê∆∞·ªùng MA' n√™u h∆∞·ªõng (l√™n/xu·ªëng/ƒëi ngang) + vai tr√≤ (h·ªó tr·ª£/kh√°ng c·ª±) theo ƒë·ªô d·ªëc & v·ªã tr√≠ gi√°.\n"
        "- 'Kh·ªëi l∆∞·ª£ng' so s√°nh trung b√¨nh 20 vs 60 phi√™n.\n"
        "- 'H·ªó tr·ª£ & Kh√°ng c·ª±' d·ª±a pivot g·∫ßn nh·∫•t, MA v√† 52W.\n"
        "- 'L∆∞·ªõt s√≥ng/Trung h·∫°n' c√≥ v√πng mua tham kh·∫£o, stoploss (~1‚Äì1.5√óATR%), m·ª•c ti√™u theo kh√°ng c·ª±/ƒë·ªânh c≈©.\n"
        "- ƒê·ªãnh d·∫°ng s·ªë c√≥ **d·∫•u ph·∫©y** (vd 31,000). Kh√¥ng coi ƒë√¢y l√† khuy·∫øn ngh·ªã ƒë·∫ßu t∆∞."
    )
    
    used_prompt = prompt or default_prompt
    guidance = used_prompt.format(template=formatted_template)
    
    # S·ª≠ d·ª•ng system prompt t·ª´ tham s·ªë ho·∫∑c m·∫∑c ƒë·ªãnh
    default_system_prompt = "B·∫°n l√† chuy√™n gia ph√¢n t√≠ch k·ªπ thu·∫≠t c·ªï phi·∫øu Vi·ªát Nam, vi·∫øt b√°o c√°o theo template ƒë∆∞·ª£c cung c·∫•p."
    used_system_prompt = system_prompt or default_system_prompt

    payload = {"symbol": symbol, **tech_stats}
    try:
        client = OpenAI(api_key=api_key)
        msgs = [
            {"role": "system", "content": used_system_prompt},
            {"role": "user", "content": guidance + "\n\nD·ªÆ LI·ªÜU:\n" + json.dumps(payload, ensure_ascii=False)}
        ]
        out = client.chat.completions.create(model=model, messages=msgs, temperature=0.15, max_tokens=1000)
        text = out.choices[0].message.content if out and out.choices else ""
        return text or "_Kh√¥ng c√≥ n·ªôi dung_"
    except Exception as e:
        return f"‚ùå L·ªói g·ªçi LLM: {e}"

# =========================
# Sidebar ‚Äî Watchlist Manager
# =========================
# Enhanced Sidebar - Simplified
# =========================
with st.sidebar:
    st.markdown("""
    <div class="section-header">
        <h3>üóÇÔ∏è Qu·∫£n l√Ω Watchlists</h3>
    </div>
    """, unsafe_allow_html=True)
    
    st.markdown("""
    <div class="control-panel" style="margin-top: 0;">
    """, unsafe_allow_html=True)

    # --- Kh·ªüi t·∫°o state ---
    if "watchlists" not in st.session_state:
        # M·∫∑c ƒë·ªãnh v√†i v√≠ d·ª•. B·∫°n c√≥ th·ªÉ s·ª≠a/ƒë·ªïi t√™n/ƒë·ªïi m√£ tr·ª±c ti·∫øp.
        st.session_state.watchlists = {
            "My Picks": ["FPT", "VNM", "HPG", "MWG", "SSI", "VCB"],
            "Banking": ["VCB", "CTG", "BID", "TCB", "VPB", "MBB", "TPB", "ACB", "STB", "EIB", "SHB"],
            "Bluechips": ["VIC", "VHM", "VRE", "VNM", "SAB", "PLX", "GAS", "FPT", "MWG", "HPG", "SSI", "VCB"],
        }
    if "current_watchlist" not in st.session_state:
        st.session_state.current_watchlist = "My Picks"

    # Hi·ªÉn th·ªã s·ªë l∆∞·ª£ng danh s√°ch
    total_lists = len(st.session_state.watchlists)
    total_symbols = sum(len(symbols) for symbols in st.session_state.watchlists.values())
    
    st.markdown(f"""
    <div class="metric-card">
        <strong>üìã {total_lists}</strong> danh s√°ch | <strong>üìà {total_symbols}</strong> m√£ c·ªï phi·∫øu
    </div>
    """, unsafe_allow_html=True)

    wl_names = sorted(st.session_state.watchlists.keys())
    if st.session_state.current_watchlist not in wl_names:
        wl_names = (wl_names + [st.session_state.current_watchlist]) if st.session_state.current_watchlist else wl_names
    

    # ƒê∆∞a ph·∫ßn ch·ªçn danh s√°ch ƒëang ph√¢n t√≠ch l√™n ƒë·∫ßu
    st.session_state.current_watchlist = st.selectbox(
        "üéØ ƒêang ph√¢n t√≠ch danh s√°ch",
        options=sorted(st.session_state.watchlists.keys()),
        index=sorted(st.session_state.watchlists.keys()).index(st.session_state.current_watchlist),
        key="active_watchlist_picker",
        help="Danh s√°ch n√†y s·∫Ω ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ ph√¢n t√≠ch khi nh·∫•n n√∫t Ph√¢n t√≠ch"
    )

    selected_wl = st.session_state.current_watchlist

    # Ch·ªçn danh s√°ch ƒë·ªÉ thao t√°c (·∫©n label)
    wl_names = sorted(st.session_state.watchlists.keys())
    new_wl_name = st.text_input(
        label="",
        value="",
        placeholder="T√™n danh s√°ch m·ªõi",
        key="new_wl_name_input",
        label_visibility="collapsed",
        help="Nh·∫≠p t√™n ƒë·ªÉ t·∫°o danh s√°ch m·ªõi"
    )

    # √î text ch·ªânh m√£ cho watchlist ƒëang ch·ªçn (·∫©n label)
    current_symbols_str = ", ".join(st.session_state.watchlists.get(selected_wl, []))
    edited_symbols_str = st.text_area(
        label="",
        value=current_symbols_str,
        key=f"wl_text_{selected_wl}",
        label_visibility="collapsed",
        help="V√≠ d·ª•: FPT, VNM, HPG, SSI (ch·ªâ ch·∫•p nh·∫≠n m√£ 3 k√Ω t·ª±)",
        height=100
    )

    st.markdown("</div>", unsafe_allow_html=True)

    # Action buttons ch·ªâ hi·ªán icon
    col_btn1, col_btn2, col_btn3 = st.columns([1, 1, 1])
    with col_btn1:
        if st.button("", use_container_width=True, help="L∆∞u danh s√°ch", key="save_btn", type="secondary", icon="üíæ"):
            cleaned = _filter_company_tickers_only(_parse_symbols_input(edited_symbols_str))
            st.session_state.watchlists[selected_wl] = cleaned
            st.success(f"‚úÖ ƒê√£ l∆∞u '{selected_wl}' ({len(cleaned)} m√£)")
    with col_btn2:
        if st.button("", use_container_width=True, help="T·∫°o danh s√°ch m·ªõi", key="create_btn", type="secondary", icon="‚ûï"):
            name = (new_wl_name or "").strip()
            if not name:
                st.warning("‚ö†Ô∏è Vui l√≤ng nh·∫≠p t√™n danh s√°ch")
            elif name in st.session_state.watchlists:
                st.warning("‚ö†Ô∏è T√™n ƒë√£ t·ªìn t·∫°i")
            else:
                cleaned = _filter_company_tickers_only(_parse_symbols_input(edited_symbols_str))
                st.session_state.watchlists[name] = cleaned
                st.session_state.current_watchlist = name
                st.success(f"‚úÖ ƒê√£ t·∫°o '{name}' ({len(cleaned)} m√£)")
    with col_btn3:
        if st.button("", use_container_width=True, help="X√≥a danh s√°ch", key="delete_btn", type="secondary", icon="üóëÔ∏è"):
            if selected_wl in st.session_state.watchlists:
                if len(st.session_state.watchlists) <= 1:
                    st.warning("‚ö†Ô∏è C·∫ßn √≠t nh·∫•t 1 danh s√°ch")
                else:
                    del st.session_state.watchlists[selected_wl]
                    st.session_state.current_watchlist = next(iter(st.session_state.watchlists.keys()))
                    st.success(f"‚úÖ ƒê√£ x√≥a '{selected_wl}'")
    
    # =========================
    # AI Reports Management
    # =========================
    st.markdown("---")
    st.markdown("""
    <div class="section-header">
        <h3>ü§ñ B√°o c√°o AI</h3>
    </div>
    """, unsafe_allow_html=True)
    
    cached_reports = st.session_state.get("form_cache", {})
    if cached_reports:
        st.info(f"üìù C√≥ {len(cached_reports)} b√°o c√°o AI trong cache")
        
        # Hi·ªÉn th·ªã danh s√°ch b√°o c√°o
        for symbol in sorted(cached_reports.keys()):
            with st.expander(f"üìÑ {symbol}", expanded=False):
                report_text = cached_reports[symbol]
                st.markdown(report_text)
                
                # N√∫t download cho t·ª´ng b√°o c√°o
                st.download_button(
                    label="‚¨áÔ∏è T·∫£i b√°o c√°o",
                    data="\ufeff" + report_text,
                    file_name=f"{symbol}_AI_Report.txt",
                    mime="text/plain; charset=utf-8",
                    key=f"download_{symbol}"
                )
        
        # N√∫t x√≥a t·∫•t c·∫£ b√°o c√°o
        if st.button("üóëÔ∏è X√≥a t·∫•t c·∫£ b√°o c√°o AI", key="clear_all_reports", 
                    help="X√≥a t·∫•t c·∫£ b√°o c√°o AI ƒë√£ cached", type="secondary"):
            st.session_state["form_cache"] = {}
            st.success("‚úÖ ƒê√£ x√≥a t·∫•t c·∫£ b√°o c√°o AI")
            st.rerun()
            
        # N√∫t download t·∫•t c·∫£ b√°o c√°o
        if len(cached_reports) > 1:
            all_reports = ""
            for symbol, report in cached_reports.items():
                all_reports += f"{'='*50}\n"
                all_reports += f"B√ÅO C√ÅO PH√ÇN T√çCH: {symbol}\n"
                all_reports += f"{'='*50}\n\n"
                all_reports += report + "\n\n"
            
            st.download_button(
                label="üì¶ T·∫£i t·∫•t c·∫£ b√°o c√°o",
                data="\ufeff" + all_reports,
                file_name="All_AI_Reports.txt",
                mime="text/plain; charset=utf-8",
                key="download_all_reports"
            )
    else:
        st.info("üìù Ch∆∞a c√≥ b√°o c√°o AI n√†o. Nh·∫≠p API key v√† ph√¢n t√≠ch ƒë·ªÉ t·∫°o b√°o c√°o t·ª± ƒë·ªông.")

# =========================
# MAIN CONTENT - Quick Analysis Section
# =========================

# Quick Analysis Panel (·ªü ƒë·∫ßu)
col_main1, col_main2 = st.columns([2, 1])

with col_main1:
    # Hi·ªÉn th·ªã danh s√°ch ƒëang ch·ªçn
    active_wl_name = st.session_state.current_watchlist
    current_symbols = st.session_state.watchlists.get(active_wl_name, [])
    
    st.markdown(f"""
    <div class="metric-card" style="padding: 1rem; margin-bottom: 1rem;">
        <h4>üìÇ Danh s√°ch: {active_wl_name}</h4>
        <p><strong>{len(current_symbols)}</strong> m√£ c·ªï phi·∫øu: {', '.join(current_symbols[:10])}{' ...' if len(current_symbols) > 10 else ''}</p>
    </div>
    """, unsafe_allow_html=True)

with col_main2:
    # N√∫t ph√¢n t√≠ch ch√≠nh
    analyze_btn = st.button(
        "üöÄ B·∫Øt ƒë·∫ßu ph√¢n t√≠ch", 
        use_container_width=True,
        type="primary",
        help="Nh·∫•n ƒë·ªÉ b·∫Øt ƒë·∫ßu ph√¢n t√≠ch c√°c c·ªï phi·∫øu trong danh s√°ch"
    )

# Advanced Configuration (c√≥ th·ªÉ ·∫©n/hi·ªán)
with st.expander("‚öôÔ∏è C·∫•u h√¨nh n√¢ng cao", expanded=False):
    col_config1, col_config2 = st.columns(2)
    
    with col_config1:
        st.markdown("**üìä Tham s·ªë ph√¢n t√≠ch**")
        days = st.number_input(
            "üìÖ S·ªë ng√†y l·ªãch s·ª≠", 
            60, 1500, 360, 30, 
            help="S·ªë ng√†y d·ªØ li·ªáu gi√° ƒë·ªÉ ph√¢n t√≠ch (‚â•252 cho ƒë·ªß 52 tu·∫ßn)"
        )
        
        tminus = st.number_input(
            "‚è∞ L√πi ng√†y (T-n)", 
            0, 30, 0, 1,
            help="L√πi ng√†y k·∫øt th√∫c ƒë·ªÉ ph√¢n t√≠ch d·ªØ li·ªáu tr∆∞·ªõc ƒë√≥"
        )
        
        end_date = st.text_input(
            "üìÖ Ng√†y k·∫øt th√∫c", 
            value="",
            placeholder="YYYY-MM-DD ho·∫∑c ƒë·ªÉ tr·ªëng",
            help="Ng√†y k·∫øt th√∫c ph√¢n t√≠ch (m·∫∑c ƒë·ªãnh: h√¥m nay)"
        )

    with col_config2:
        st.markdown("**ü§ñ C·∫•u h√¨nh AI**")
        api_key_default = st.session_state.get("openai_api_key", "")
        api_key_input = st.text_input(
            "üîë OpenAI API Key", 
            value=api_key_default, 
            type="password",
            help="API key ƒë·ªÉ t·∫°o b√°o c√°o ph√¢n t√≠ch b·∫±ng AI"
        )
        if api_key_input:
            st.session_state["openai_api_key"] = api_key_input
        
        llm_model = st.text_input(
            "üß† Model AI", 
            value="gpt-4o-mini",
            help="M√¥ h√¨nh AI ƒë·ªÉ t·∫°o b√°o c√°o"
        )
        
        polite_delay_ms = st.slider(
            "‚è±Ô∏è ƒê·ªô tr·ªÖ API (ms)", 
            0, 1000, 300, 50,
            help="Th·ªùi gian ch·ªù gi·ªØa c√°c l·ªánh g·ªçi API"
        )

# =========================
# C·∫•u h√¨nh Prompt v√† Template (Ri√™ng bi·ªát)
# =========================
with st.expander("üìù C·∫•u h√¨nh Prompt & Template AI", expanded=False):
    st.markdown("### üõ†Ô∏è T√πy ch·ªânh c√°ch AI t·∫°o b√°o c√°o ph√¢n t√≠ch")
    st.info("üí° **H∆∞·ªõng d·∫´n:** B·∫°n c√≥ th·ªÉ t√πy ch·ªânh template b√°o c√°o v√† prompt h∆∞·ªõng d·∫´n ƒë·ªÉ AI t·∫°o ra b√°o c√°o theo √Ω mu·ªën.")
    
    col_template, col_prompt = st.columns(2)
    
    with col_template:
        st.markdown("**üìã Template b√°o c√°o**")
        # Template configuration
        default_template = (
            "PH√ÇN T√çCH K·ª∏ THU·∫¨T\n\n"
            "1. Xu h∆∞·ªõng gi√°:\n- ...\n- ...\n- ...\n\n"
            "2. ƒê∆∞·ªùng MA (20/50/200):\n- MA20: ...\n- MA50: ...\n- MA200: ...\n\n"
            "3. Kh·ªëi l∆∞·ª£ng:\n- ...\n- ...\n\n"
            "4. H·ªó tr·ª£ & Kh√°ng c·ª±:\n- Kh√°ng c·ª±: ...\n- H·ªó tr·ª£ g·∫ßn: ...\n- H·ªó tr·ª£ s√¢u: ...\n\n"
            "NH·∫¨N ƒê·ªäNH NHANH & CHI·∫æN L∆Ø·ª¢C\n\n"
            "- Ng·∫Øn h·∫°n: ...\n- Trung h·∫°n: ...\n\n"
            "Chi·∫øn l∆∞·ª£c:\n- L∆∞·ªõt s√≥ng: ...\n- Trung h·∫°n: ..."
        )
        
        analysis_template = st.text_area(
            "Template m·∫´u b√°o c√°o",
            value=st.session_state.get("analysis_template", default_template),
            height=300,
            help="ƒê·ªãnh d·∫°ng template cho b√°o c√°o ph√¢n t√≠ch. S·ª≠ d·ª•ng ... ƒë·ªÉ AI ƒëi·ªÅn n·ªôi dung.",
            key="template_area"
        )
        st.session_state["analysis_template"] = analysis_template
        
        if st.button("üîÑ Reset Template", help="Kh√¥i ph·ª•c template m·∫∑c ƒë·ªãnh", key="reset_template"):
            st.session_state["analysis_template"] = default_template
            st.rerun()
    
    with col_prompt:
        st.markdown("**üí¨ Prompt h∆∞·ªõng d·∫´n**")
        # Prompt configuration
        default_prompt = (
            "B·∫°n l√† chuy√™n gia PTKT c·ªï phi·∫øu Vi·ªát Nam. D·ª±a **duy nh·∫•t** v√†o d·ªØ li·ªáu cung c·∫•p, "
            "h√£y vi·∫øt b√°o c√°o ƒë√∫ng **form m·∫´u** (ti·∫øng Vi·ªát, ng·∫Øn g·ªçn). Ch·ªâ ƒë√°nh gi√° MA20/MA50/MA200.\n\n"
            "TEMPLATE:\n{template}\n\n"
            "H∆Ø·ªöNG D·∫™N:\n"
            "- 'ƒê∆∞·ªùng MA' n√™u h∆∞·ªõng (l√™n/xu·ªëng/ƒëi ngang) + vai tr√≤ (h·ªó tr·ª£/kh√°ng c·ª±) theo ƒë·ªô d·ªëc & v·ªã tr√≠ gi√°.\n"
            "- 'Kh·ªëi l∆∞·ª£ng' so s√°nh trung b√¨nh 20 vs 60 phi√™n.\n"
            "- 'H·ªó tr·ª£ & Kh√°ng c·ª±' d·ª±a pivot g·∫ßn nh·∫•t, MA v√† 52W.\n"
            "- 'L∆∞·ªõt s√≥ng/Trung h·∫°n' c√≥ v√πng mua tham kh·∫£o, stoploss (~1‚Äì1.5√óATR%), m·ª•c ti√™u theo kh√°ng c·ª±/ƒë·ªânh c≈©.\n"
            "- ƒê·ªãnh d·∫°ng s·ªë c√≥ **d·∫•u ph·∫©y** (vd 31,000). Kh√¥ng coi ƒë√¢y l√† khuy·∫øn ngh·ªã ƒë·∫ßu t∆∞."
        )
        
        analysis_prompt = st.text_area(
            "H∆∞·ªõng d·∫´n chi ti·∫øt cho AI",
            value=st.session_state.get("analysis_prompt", default_prompt),
            height=200,
            help="H∆∞·ªõng d·∫´n cho AI v·ªÅ c√°ch ph√¢n t√≠ch. S·ª≠ d·ª•ng {template} ƒë·ªÉ ch√®n template.",
            key="prompt_area"
        )
        st.session_state["analysis_prompt"] = analysis_prompt
        
        # System prompt configuration
        default_system_prompt = "B·∫°n l√† chuy√™n gia ph√¢n t√≠ch k·ªπ thu·∫≠t c·ªï phi·∫øu Vi·ªát Nam, vi·∫øt b√°o c√°o theo template ƒë∆∞·ª£c cung c·∫•p."
        
        system_prompt = st.text_area(
            "System Prompt (Vai tr√≤ AI)",
            value=st.session_state.get("system_prompt", default_system_prompt),
            height=80,
            help="Vai tr√≤ v√† ng·ªØ c·∫£nh cho AI.",
            key="system_prompt_area"
        )
        st.session_state["system_prompt"] = system_prompt
        
        if st.button("üîÑ Reset Prompts", help="Kh√¥i ph·ª•c prompts m·∫∑c ƒë·ªãnh", key="reset_prompts"):
            st.session_state["analysis_prompt"] = default_prompt
            st.session_state["system_prompt"] = default_system_prompt
            st.rerun()
    
    # Preview section
    st.markdown("---")
    st.markdown("**üëÅÔ∏è Xem tr∆∞·ªõc c·∫•u h√¨nh hi·ªán t·∫°i:**")
    
    col_preview1, col_preview2 = st.columns(2)
    with col_preview1:
        with st.container(border=True):
            st.markdown("**Template s·∫Ω s·ª≠ d·ª•ng:**")
            st.code(st.session_state.get("analysis_template", default_template)[:200] + "...", language="text")
    
    with col_preview2:
        with st.container(border=True):
            st.markdown("**System Prompt:**")
            st.code(st.session_state.get("system_prompt", default_system_prompt), language="text")
    
    # Template presets
    st.markdown("---")
    st.markdown("**üé® Template c√≥ s·∫µn:**")
    
    col_preset1, col_preset2, col_preset3 = st.columns(3)
    
    with col_preset1:
        if st.button("üìä Template C∆° b·∫£n", help="Template ph√¢n t√≠ch c∆° b·∫£n", key="preset_basic"):
            st.session_state["analysis_template"] = default_template
            st.rerun()
    
    with col_preset2:
        if st.button("üìà Template Chi ti·∫øt", help="Template ph√¢n t√≠ch chi ti·∫øt h∆°n", key="preset_detailed"):
            detailed_template = (
                "PH√ÇN T√çCH K·ª∏ THU·∫¨T CHI TI·∫æT\n\n"
                "1. T·ªïng quan th·ªã tr∆∞·ªùng:\n- Xu h∆∞·ªõng t·ªïng th·ªÉ: ...\n- V·ªã tr√≠ trong chu k·ª≥: ...\n\n"
                "2. Ph√¢n t√≠ch gi√°:\n- Xu h∆∞·ªõng ng·∫Øn h·∫°n (1-5 ng√†y): ...\n- Xu h∆∞·ªõng trung h·∫°n (1-4 tu·∫ßn): ...\n- Xu h∆∞·ªõng d√†i h·∫°n (1-3 th√°ng): ...\n\n"
                "3. ƒê∆∞·ªùng trung b√¨nh ƒë·ªông:\n- SMA9: ...\n- SMA20: ...\n- SMA50: ...\n- SMA200: ...\n\n"
                "4. Kh·ªëi l∆∞·ª£ng giao d·ªãch:\n- Kh·ªëi l∆∞·ª£ng hi·ªán t·∫°i vs TB20: ...\n- Kh·ªëi l∆∞·ª£ng hi·ªán t·∫°i vs TB60: ...\n- ƒê√°nh gi√° thanh kho·∫£n: ...\n\n"
                "5. H·ªó tr·ª£ & Kh√°ng c·ª±:\n- Kh√°ng c·ª± g·∫ßn nh·∫•t: ...\n- Kh√°ng c·ª± m·∫°nh: ...\n- H·ªó tr·ª£ g·∫ßn nh·∫•t: ...\n- H·ªó tr·ª£ m·∫°nh: ...\n\n"
                "6. Ch·ªâ b√°o k·ªπ thu·∫≠t:\n- RSI: ...\n- ATR: ...\n- ƒê·ªânh/ƒë√°y 52 tu·∫ßn: ...\n\n"
                "CHI·∫æN L∆Ø·ª¢C ƒê·∫¶U T∆Ø\n\n"
                "‚Ä¢ Ng·∫Øn h·∫°n (1-2 tu·∫ßn):\n- Xu h∆∞·ªõng: ...\n- V√πng mua: ...\n- Stop-loss: ...\n- Take-profit: ...\n\n"
                "‚Ä¢ Trung h·∫°n (1-3 th√°ng):\n- Xu h∆∞·ªõng: ...\n- V√πng t√≠ch l≈©y: ...\n- M·ª•c ti√™u: ...\n\n"
                "‚Ä¢ R·ªßi ro c·∫ßn l∆∞u √Ω: ..."
            )
            st.session_state["analysis_template"] = detailed_template
            st.rerun()
    
    with col_preset3:
        if st.button("‚ö° Template Nhanh", help="Template b√°o c√°o ng·∫Øn g·ªçn", key="preset_quick"):
            quick_template = (
                "PH√ÇN T√çCH NHANH\n\n"
                "üìà Xu h∆∞·ªõng: ...\n"
                "üìä MA20/50/200: ... / ... / ...\n"
                "üì¶ Kh·ªëi l∆∞·ª£ng: ...\n"
                "üî∫ Kh√°ng c·ª±: ...\n"
                "üîª H·ªó tr·ª£: ...\n\n"
                "‚ö° CHI·∫æN L∆Ø·ª¢C:\n"
                "‚Ä¢ Ng·∫Øn h·∫°n: ...\n"
                "‚Ä¢ V√πng mua: ...\n"
                "‚Ä¢ Stop-loss: ...\n"
                "‚Ä¢ M·ª•c ti√™u: ..."
            )
            st.session_state["analysis_template"] = quick_template
            st.rerun()
    
    # Import/Export configuration
    st.markdown("---")
    st.markdown("**üíæ Sao l∆∞u & Kh√¥i ph·ª•c c·∫•u h√¨nh:**")
    
    col_export, col_import = st.columns(2)
    
    with col_export:
        if st.button("üì§ Export c·∫•u h√¨nh", help="Xu·∫•t c·∫•u h√¨nh hi·ªán t·∫°i", key="export_config"):
            config_data = {
                "analysis_template": st.session_state.get("analysis_template", default_template),
                "analysis_prompt": st.session_state.get("analysis_prompt", default_prompt),
                "system_prompt": st.session_state.get("system_prompt", default_system_prompt)
            }
            config_json = json.dumps(config_data, ensure_ascii=False, indent=2)
            st.download_button(
                label="‚¨áÔ∏è T·∫£i file c·∫•u h√¨nh",
                data=config_json,
                file_name="ai_analysis_config.json",
                mime="application/json"
            )
    
    with col_import:
        uploaded_config = st.file_uploader(
            "üì§ Import c·∫•u h√¨nh", 
            type=["json"], 
            help="T·∫£i l√™n file c·∫•u h√¨nh ƒë√£ xu·∫•t tr∆∞·ªõc ƒë√≥",
            key="import_config"
        )
        
        if uploaded_config is not None:
            try:
                config_data = json.load(uploaded_config)
                st.session_state["analysis_template"] = config_data.get("analysis_template", default_template)
                st.session_state["analysis_prompt"] = config_data.get("analysis_prompt", default_prompt)
                st.session_state["system_prompt"] = config_data.get("system_prompt", default_system_prompt)
                st.success("‚úÖ ƒê√£ import c·∫•u h√¨nh th√†nh c√¥ng!")
                st.rerun()
            except Exception as e:
                st.error(f"‚ùå L·ªói khi import c·∫•u h√¨nh: {e}")

# =========================
# Resolve dates & symbols with default values
# =========================
# Set default values for removed variables
max_symbols = 200  # Kh√¥ng gi·ªõi h·∫°n s·ªë m√£
min_adtv = 0  # Kh√¥ng l·ªçc thanh kho·∫£n
sources_str = "TCBS"  # Ngu·ªìn m·∫∑c ƒë·ªãnh
show_charts = True  # Lu√¥n hi·ªÉn th·ªã bi·ªÉu ƒë·ªì
show_ma9 = True  # SMA9 m·∫∑c ƒë·ªãnh hi·ªÉn th·ªã
show_ma20 = True  # SMA20 m·∫∑c ƒë·ªãnh hi·ªÉn th·ªã
show_ma50 = True  # SMA50 m·∫∑c ƒë·ªãnh hi·ªÉn th·ªã
show_ma200 = True  # SMA200 m·∫∑c ƒë·ªãnh hi·ªÉn th·ªã
show_bollinger = True  # Bollinger Bands m·∫∑c ƒë·ªãnh hi·ªÉn th·ªã

# L·∫•y gi√° tr·ªã t·ª´ config ho·∫∑c d√πng m·∫∑c ƒë·ªãnh
if 'days' not in locals():
    days = 360
if 'tminus' not in locals():
    tminus = 0
if 'end_date' not in locals():
    end_date = ""
if 'polite_delay_ms' not in locals():
    polite_delay_ms = 300

if tminus and tminus > 0:
    ed = _prev_weekday(datetime.today() - timedelta(days=int(tminus)))
else:
    ed = _prev_weekday(datetime.today())
    if end_date.strip():
        try:
            ed = _prev_weekday(pd.to_datetime(end_date))
        except Exception:
            st.warning("Ng√†y k·∫øt th√∫c kh√¥ng h·ª£p l·ªá, d√πng ng√†y l√†m vi·ªác g·∫ßn nh·∫•t.")
ed_str = ed.strftime("%Y-%m-%d")
sources = [s.strip().upper() for s in (sources_str or "TCBS").split(",") if s.strip()]

# L·∫•y m√£ t·ª´ watchlist ƒëang ch·ªçn
active_wl_name = st.session_state.current_watchlist
symbols_all = _filter_company_tickers_only(st.session_state.watchlists.get(active_wl_name, []))
symbols = symbols_all[:max_symbols]
if len(symbols_all) > len(symbols):
    st.info(f"ƒê√£ gi·ªõi h·∫°n {len(symbols)}/{len(symbols_all)} m√£ ƒë·ªÉ tr√°nh rate-limit.")

# =========================
# Main: run analysis once & store
# =========================
def run_analysis_and_store():
    if not symbols:
        st.error("Danh s√°ch hi·ªán tr·ªëng ho·∫∑c kh√¥ng c√≥ m√£ h·ª£p l·ªá (3 k√Ω t·ª± ch·ªØ c√°i).")
        return

    st.info(f"ƒêang ph√¢n t√≠ch **{len(symbols)}** m√£ t·ª´ watchlist **{active_wl_name}** ¬∑ days={days} ¬∑ end={ed_str} ¬∑ sources={sources}")

    primary_source_for_fund = sources[0] if sources else "TCBS"
    snap_df = _get_screener_snapshot_cached(primary_source_for_fund)  # ch·ªâ ƒë·ªÉ l·∫•y sector n·∫øu c√≥
    sector_map = _extract_sector_map_from_snapshot(snap_df)  # c√≥ th·ªÉ r·ªóng n·∫øu kh√¥ng l·∫•y ƒë∆∞·ª£c

    rows_feat: List[Dict] = []
    px_map: Dict[str, pd.DataFrame] = {}

    try:
        prog = st.progress(0, text="Ch∆∞a b·∫Øt ƒë·∫ßu")
        prog_text = None
    except TypeError:
        prog = st.progress(0)
        prog_text = st.empty()

    price_sources = [sources[0]] if sources else ["TCBS"]

    for i, sym in enumerate(symbols, 1):
        label = f"ƒêang t·∫£i d·ªØ li·ªáu {i}/{len(symbols)} - {sym}"
        try:
            prog.progress(i/len(symbols), text=label)
        except TypeError:
            prog.progress(i/len(symbols))
            if prog_text: prog_text.markdown(f"**{label}**")

        # Gi√°
        try:
            px = _get_quote_history_cached(sym, int(days), ed_str, price_sources)
        except Exception:
            px = pd.DataFrame()
        px_map[sym] = px

        # Fundamentals (rev_yoy t·ª´ TCBS API ‚Äì x·ª≠ l√Ω trong adapter)
        fund_precise = _get_fundamentals_precise_cached(sym, source=primary_source_for_fund, period="quarter")

        # T√≠nh features t·ª´ px + fund
        feat = {"symbol": sym}
        feat.update(compute_features_local_from_px(px, fund_precise))
        rows_feat.append(feat)

        if polite_delay_ms > 0:
            time.sleep(polite_delay_ms / 1000.0)

    df_feat = pd.DataFrame(rows_feat)

    # Th√™m sector (n·∫øu c√≥)
    if not df_feat.empty:
        df_feat["sector"] = df_feat["symbol"].map(lambda s: sector_map.get(str(s).upper(), ""))

    # B·∫£o ƒë·∫£m c√°c c·ªôt c√≥ t·ªìn t·∫°i
    for col in ["pe","pb","roe","net_margin","de","rev_yoy","eps_yoy","m1","m3","m6","adtv","vol"]:
        if col not in df_feat.columns:
            df_feat[col] = np.nan
        if df_feat[col].notna().sum() == 0:
            df_feat[col] = 0.0

    ranked = score_symbols(df_feat, ScoreWeights(), min_adtv=float(min_adtv))

    st.session_state["screener_store"] = {
        "ranked": ranked, "df_feat": df_feat, "px_map": px_map,
        "ed_str": ed_str, "sources": sources, "params": dict(days=days, min_adtv=min_adtv),
        "snapshot_df": snap_df,
        "active_watchlist": active_wl_name,
    }
    if "form_cache" not in st.session_state:
        st.session_state["form_cache"] = {}

def auto_analyze_all_symbols_in_background():
    """T·ª± ƒë·ªông ph√¢n t√≠ch t·∫•t c·∫£ c√°c m√£ trong n·ªÅn n·∫øu c√≥ API key"""
    api_key = st.session_state.get("openai_api_key", "") or ""
    if not api_key or not _OPENAI_OK:
        return
    
    store = st.session_state.get("screener_store", {})
    if not store:
        return
        
    ranked = store.get("ranked", pd.DataFrame())
    if ranked.empty:
        return
        
    # L·∫•y top symbols
    top_syms = ranked.head(20)["symbol"].tolist()
    px_map = store.get("px_map", {})
    snapshot_df = store.get("snapshot_df", pd.DataFrame())
    
    # ƒê·∫øm s·ªë m√£ ch∆∞a c√≥ b√°o c√°o
    cached_reports = st.session_state.get("form_cache", {})
    symbols_to_analyze = [sym for sym in top_syms if sym not in cached_reports]
    
    if not symbols_to_analyze:
        st.success("‚úÖ T·∫•t c·∫£ c√°c m√£ ƒë√£ c√≥ b√°o c√°o AI!")
        return
    
    # Hi·ªÉn th·ªã progress
    st.info(f"ü§ñ ƒêang t·ª± ƒë·ªông t·∫°o b√°o c√°o AI cho {len(symbols_to_analyze)} m√£ trong n·ªÅn...")
    progress_bar = st.progress(0)
    status_text = st.empty()
    
    # Ph√¢n t√≠ch t·ª´ng m√£
    for i, symbol in enumerate(symbols_to_analyze):
        status_text.text(f"ƒêang ph√¢n t√≠ch {symbol} ({i+1}/{len(symbols_to_analyze)})...")
        
        # L·∫•y d·ªØ li·ªáu k·ªπ thu·∫≠t
        px_sel = px_map.get(symbol, pd.DataFrame())
        if px_sel.empty:
            continue
            
        tech_stats = build_structured_stats(px_sel)
        company_name = _company_name_from_snapshot(snapshot_df, symbol)
        
        # T·∫°o b√°o c√°o
        try:
            model = st.session_state.get("llm_model", "gpt-4o-mini")
            template = st.session_state.get("analysis_template", "")
            prompt = st.session_state.get("analysis_prompt", "")
            system_prompt = st.session_state.get("system_prompt", "")
            
            report = call_llm_structured_report(
                api_key, model, symbol, tech_stats,
                template=template, prompt=prompt, system_prompt=system_prompt, company_name=company_name
            )
            st.session_state.setdefault("form_cache", {})[symbol] = report
        except Exception as e:
            st.warning(f"‚ö†Ô∏è L·ªói t·∫°o b√°o c√°o cho {symbol}: {e}")
        
        # C·∫≠p nh·∫≠t progress
        progress_bar.progress((i + 1) / len(symbols_to_analyze))
    
    status_text.text("Ho√†n th√†nh!")
    progress_bar.progress(1.0)
    st.success(f"üéâ ƒê√£ t·∫°o xong b√°o c√°o AI cho {len(symbols_to_analyze)} m√£!")

if analyze_btn:
    with st.spinner("üîÑ ƒêang ph√¢n t√≠ch d·ªØ li·ªáu..."):
        run_analysis_and_store()
    
    # T·ª± ƒë·ªông ph√¢n t√≠ch AI trong n·ªÅn n·∫øu c√≥ API key
    auto_analyze_all_symbols_in_background()

# =========================
# Enhanced Results Display
# =========================
store = st.session_state.get("screener_store")

if store is None:
    st.markdown("""
    <div class="metric-card" style="text-align: center; padding: 2rem;">
        <h4>üëã Ch√†o m·ª´ng ƒë·∫øn v·ªõi Stock Screener</h4>
        <p>Vui l√≤ng ch·ªçn danh s√°ch c·ªï phi·∫øu trong sidebar v√† nh·∫•n n√∫t <strong>üöÄ B·∫Øt ƒë·∫ßu ph√¢n t√≠ch</strong> ƒë·ªÉ b·∫Øt ƒë·∫ßu.</p>
        <br>
        <div class="status-indicator status-warning"></div>
        <small>Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ hi·ªÉn th·ªã</small>
    </div>
    """, unsafe_allow_html=True)
else:
    ranked = store["ranked"]; px_map = store["px_map"]
    
    # Summary metrics
    total_analyzed = len(ranked)
    top_performer = ranked.iloc[0]['symbol'] if len(ranked) > 0 else "N/A"
    
    st.markdown(f"""
    <div class="section-header">
        <h3>üèÜ K·∫øt qu·∫£ ph√¢n t√≠ch - {store.get('active_watchlist','Danh s√°ch')}</h3>
    </div>
    """, unsafe_allow_html=True)
    
    # Summary cards
    col1, col2, col3 = st.columns(3)
    with col1:
        st.markdown(f"""
        <div class="metric-card">
            <h4>üìä T·ªïng s·ªë m√£</h4>
            <h2 style="color: #2a5298;">{total_analyzed}</h2>
            <small>C·ªï phi·∫øu ƒë√£ ph√¢n t√≠ch</small>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown(f"""
        <div class="metric-card">
            <h4>ü•á Top performer</h4>
            <h2 style="color: #28a745;">{top_performer}</h2>
            <small>C·ªï phi·∫øu t·ªët nh·∫•t</small>
        </div>
        """, unsafe_allow_html=True)
    
    with col3:
        analyzed_date = store.get('ed_str', 'N/A')
        st.markdown(f"""
        <div class="metric-card">
            <h4>üìÖ Ng√†y ph√¢n t√≠ch</h4>
            <h2 style="color: #2a5298; font-size: 1.2rem;">{analyzed_date}</h2>
            <small>D·ªØ li·ªáu ƒë·∫øn ng√†y</small>
        </div>
        """, unsafe_allow_html=True)

    st.markdown("<br>", unsafe_allow_html=True)
    
    # Enhanced ranking table
    st.markdown("""
    <div class="section-header">
        <h4>üìã B·∫£ng x·∫øp h·∫°ng chi ti·∫øt</h4>
    </div>
    """, unsafe_allow_html=True)
    
    view = ranked.copy()

    # ---- format helpers ----
    def pct_return(x):  # m1/m3/m6 l√† t·ªâ l·ªá (0.123)
        return "" if pd.isna(x) else f"{x*100.0:.1f}%"

    def pct_ready(x):   # ƒë√£ l√† % (vd 29.7)
        return "" if pd.isna(x) else f"{x:.1f}%"

    # Score & component scores
    for c in ("score","Value","Quality","Growth","Momentum","Liquidity","RiskAdj","pe","pb"):
        if c in view.columns:
            view[c] = view[c].apply(lambda x: "" if pd.isna(x) else (f"{x:.3f}" if c=="score" else f"{x:.2f}"))

    # Returns: m1/m3/m6 (t·ªâ l·ªá ‚Üí *100 khi hi·ªÉn th·ªã)
    for c in ("m1","m3","m6"):
        if c in view.columns:
            view[c] = view[c].apply(pct_return)

    # % metrics ƒë√£ chu·∫©n ho√° s·∫µn trong adapter: rev_yoy, roe, eps_yoy, net_margin
    for c in ("rev_yoy","roe","eps_yoy","net_margin"):
        if c in view.columns:
            view[c] = view[c].apply(pct_ready)

    # ADTV - Debug th√¥ng tin
    if "adtv" in view.columns:
        # ƒê·∫øm s·ªë m√£ c√≥ ADTV h·ª£p l·ªá - d√πng adtv_raw n·∫øu c√≥
        adtv_col = "adtv_raw" if "adtv_raw" in view.columns else "adtv"
        valid_adtv = view[adtv_col].apply(lambda x: not pd.isna(x) and x > 0).sum()
        total_stocks = len(view)
        
        # Ki·ªÉm tra kho·∫£ng gi√° tr·ªã ƒë·ªÉ quy·∫øt ƒë·ªãnh ƒë∆°n v·ªã hi·ªÉn th·ªã
        max_adtv = view[adtv_col].max() if not view[adtv_col].empty else 0
        
        if max_adtv > 1e9:  # L·ªõn h∆°n 1 t·ª∑ ‚Üí hi·ªÉn th·ªã theo t·ª∑
            view["adtv"] = view[adtv_col].apply(lambda x: "N/A" if pd.isna(x) or x <= 0 else f"{x/1e9:.1f} t·ª∑")
        elif max_adtv > 1e6:  # L·ªõn h∆°n 1 tri·ªáu ‚Üí hi·ªÉn th·ªã theo tri·ªáu
            view["adtv"] = view[adtv_col].apply(lambda x: "N/A" if pd.isna(x) or x <= 0 else f"{x/1e6:.1f} tr")
        elif max_adtv > 1e3:  # L·ªõn h∆°n 1 ngh√¨n ‚Üí hi·ªÉn th·ªã theo ngh√¨n
            view["adtv"] = view[adtv_col].apply(lambda x: "N/A" if pd.isna(x) or x <= 0 else f"{x/1e3:.1f} k")
        else:  # Nh·ªè h∆°n ‚Üí hi·ªÉn th·ªã nguy√™n gi√° tr·ªã
            view["adtv"] = view[adtv_col].apply(lambda x: "N/A" if pd.isna(x) or x <= 0 else f"{x:.2f}")

    # Th√™m c·ªôt AI Report status
    cached_reports = st.session_state.get("form_cache", {})
    view["ai_status"] = view.index.map(lambda x: "‚úÖ C√≥" if x in cached_reports else "‚è≥ Ch∆∞a")

    cols = [c for c in [
        "symbol","score","Value","Quality","Growth","Momentum","Liquidity","RiskAdj","ai_status",
        "m1","m3","m6","pe","pb","roe","rev_yoy","eps_yoy","net_margin","adtv"
    ] if c in view.columns]

    # ---- Column help / tooltips ----
    col_help = {
        "symbol": "M√£ c·ªï phi·∫øu.",
        "score": "ƒêi·ªÉm t·ªïng h·ª£p theo tr·ªçng s·ªë: Value(0.22), Quality(0.22), Growth(0.20), Momentum(0.20), Liquidity(0.10), Risk(0.06). ƒêi·ªÉm cao = c√¢n b·∫±ng h·∫•p d·∫´n.",
        "Value": "ƒê·ªãnh gi√° t∆∞∆°ng ƒë·ªëi (P/E, P/B). Cao ‚Üí r·∫ª t∆∞∆°ng ƒë·ªëi sau khi so s√°nh v·ªõi nh√≥m ng√†nh/to√†n th·ªã tr∆∞·ªùng",
        "Quality": "Ch·∫•t l∆∞·ª£ng t√†i ch√≠nh (ROE‚Üë, bi√™n r√≤ng‚Üë, D/E‚Üì). Cao ‚Üí ch·∫•t l∆∞·ª£ng t√†i ch√≠nh t·ªët & ƒë√≤n b·∫©y h·ª£p l√Ω.",
        "Growth": "T·ªïng h·ª£p Rev YoY, EPS YoY. Cao t·ªët.",
        "Momentum": "Xu h∆∞·ªõng gi√° (1‚Äì3‚Äì6 th√°ng). D∆∞∆°ng/t·ªët ‚Üí ƒëi·ªÉm cao.",
        "Liquidity": "Thanh kho·∫£n (ADTV). Cao d·ªÖ giao d·ªãch.",
        "RiskAdj": "ƒêi·ªÉm r·ªßi ro ƒëi·ªÅu ch·ªânh theo bi·∫øn ƒë·ªông (vol th·∫•p ƒë∆∞·ª£c c·ªông ƒëi·ªÉm).",
        "ai_status": "Tr·∫°ng th√°i b√°o c√°o AI. ‚úÖ = ƒê√£ c√≥ b√°o c√°o, ‚è≥ = Ch∆∞a c√≥.",
        "m1": "Hi·ªáu su·∫•t ~1 th√°ng (%). D∆∞∆°ng ‚Üí tƒÉng. √Çm ‚Üí gi·∫£m",
        "m3": "Hi·ªáu su·∫•t ~3 th√°ng (%). D∆∞∆°ng ‚Üí tƒÉng. √Çm ‚Üí gi·∫£m",
        "m6": "Hi·ªáu su·∫•t ~6 th√°ng (%). D∆∞∆°ng ‚Üí tƒÉng. √Çm ‚Üí gi·∫£m",
        "pe": "P/E ‚Äî th·∫•p th∆∞·ªùng r·∫ª h∆°n t∆∞∆°ng ƒë·ªëi (xem k√®m Quality/Growth).",
        "pb": "P/B ‚Äî th·∫•p c√≥ th·ªÉ r·∫ª h∆°n t√†i s·∫£n r√≤ng (t√πy ng√†nh).",
        "roe": "ROE (%) ‚Äî T·ª∑ su·∫•t sinh l·ªùi tr√™n v·ªën CSH (ƒë√£ chu·∫©n ho√° th√†nh %). Cao ‚Üí ch·∫•t l∆∞·ª£ng l·ª£i nhu·∫≠n t·ªët.",
        "rev_yoy": "Doanh thu YoY qu√Ω m·ªõi nh·∫•t (%) ‚Äî Cao ‚Üí tƒÉng tr∆∞·ªüng doanh thu t·ªët.",
        "eps_yoy": "TƒÉng tr∆∞·ªüng EPS theo nƒÉm (%) ‚Äî Cao ‚Üí l·ª£i nhu·∫≠n/c·ªï phi·∫øu tƒÉng.",
        "net_margin": "Bi√™n l·ª£i nhu·∫≠n r√≤ng (%). Cao ‚Üí doanh nghi·ªáp gi·ªØ l·∫°i nhi·ªÅu l·ª£i nhu·∫≠n t·ª´ doanh thu.",
        "adtv": "Gi√° tr·ªã giao d·ªãch TB 20 phi√™n (VND). Cao ‚Üí thanh kho·∫£n t·ªët.",
        "sector": "Ng√†nh (d√πng ƒë·ªÉ chu·∫©n ho√° theo ng√†nh).",
    }
    from streamlit import column_config as cc
    column_config = {
        "symbol": cc.TextColumn("M√£ CP", help=col_help["symbol"]),
        "score": cc.TextColumn("ƒêi·ªÉm t·ªïng", help=col_help["score"]),
        "Value": cc.TextColumn("ƒê·ªãnh gi√°", help=col_help["Value"]),
        "Quality": cc.TextColumn("Ch·∫•t l∆∞·ª£ng", help=col_help["Quality"]),
        "Growth": cc.TextColumn("TƒÉng tr∆∞·ªüng", help=col_help["Growth"]),
        "Momentum": cc.TextColumn("Xu h∆∞·ªõng", help=col_help["Momentum"]),
        "Liquidity": cc.TextColumn("Thanh kho·∫£n", help=col_help["Liquidity"]),
        "RiskAdj": cc.TextColumn("R·ªßi ro", help=col_help["RiskAdj"]),
        "ai_status": cc.TextColumn("AI Report", help=col_help["ai_status"]),
        "m1": cc.TextColumn("1 th√°ng (%)", help=col_help["m1"]),
        "m3": cc.TextColumn("3 th√°ng (%)", help=col_help["m3"]),
        "m6": cc.TextColumn("6 th√°ng (%)", help=col_help["m6"]),
        "pe": cc.TextColumn("P/E", help=col_help["pe"]),
        "pb": cc.TextColumn("P/B", help=col_help["pb"]),
        "roe": cc.TextColumn("ROE (%)", help=col_help["roe"]),
        "rev_yoy": cc.TextColumn("DT YoY (%)", help=col_help["rev_yoy"]),
        "eps_yoy": cc.TextColumn("EPS YoY (%)", help=col_help["eps_yoy"]),
        "net_margin": cc.TextColumn("Bi√™n LN (%)", help=col_help["net_margin"]),
        "adtv": cc.TextColumn("GTGD TB", help=col_help["adtv"]),
        "sector": cc.TextColumn("Ng√†nh", help=col_help["sector"]),
    }

    st.dataframe(
        view[cols],
        use_container_width=True,
        height=380,
        column_config=column_config
    )
    st.caption("M·∫πo: Di chu·ªôt v√†o bi·ªÉu t∆∞·ª£ng ‚ìò c·∫°nh ti√™u ƒë·ªÅ c·ªôt ƒë·ªÉ xem ch√∫ th√≠ch nhanh.")

    # Ghi ch√∫ nhanh v·ªÅ Z-Score
    with st.expander("‚ÑπÔ∏è Ghi ch√∫ nhanh v·ªÅ ph∆∞∆°ng ph√°p Z-Score s·ª≠ d·ª•ng trong b·∫£ng"):
        st.markdown(
            """
- **M·ª•c ti√™u**: ƒë∆∞a c√°c th∆∞·ªõc ƒëo kh√°c ƒë∆°n v·ªã (P/E, % tƒÉng tr∆∞·ªüng, ADTV, bi·∫øn ƒë·ªông‚Ä¶) v·ªÅ c√πng thang **chu·∫©n ho√°** ƒë·ªÉ c·ªông/tr·ª´ c√¥ng b·∫±ng.
- **Chu·∫©n ho√° theo ng√†nh** (*sector-neutral*): so s√°nh doanh nghi·ªáp **trong c√πng ng√†nh** tr∆∞·ªõc khi t·ªïng h·ª£p ƒë·ªÉ tr√°nh m√©o do ƒë·∫∑c th√π ng√†nh.
- **K·ªπ thu·∫≠t**:
  - C·∫Øt ƒëu√¥i nh·∫π outlier (*winsorize* 2%); v·ªõi th∆∞·ªõc ƒëo l·ªách ph·∫£i (ADTV, vol) d√πng `log1p`.
  - ƒêi·ªÅn thi·∫øu theo **trung v·ªã ng√†nh**, sau ƒë√≥ **trung v·ªã to√†n th·ªã tr∆∞·ªùng** n·∫øu v·∫´n thi·∫øu.
  - D√πng **robust z-score**: \\( (x - \\text{median}) / (1.4826 \\times \\text{MAD}) \\) ‚Äî b·ªÅn v·ªØng v·ªõi outlier.
  - C√°c ch·ªâ ti√™u ‚Äú**c√†ng th·∫•p c√†ng t·ªët**‚Äù (P/E, P/B, D/E, volatility) ƒë∆∞·ª£c **ƒë·∫£o d·∫•u** ƒë·ªÉ ƒëi·ªÉm cao = t·ªët.
- **Gi·∫£i th√≠ch ƒëi·ªÉm**:
  - Z ‚âà **0**: ngang trung v·ªã nh√≥m so s√°nh; **+1**: t·ªët h∆°n ƒë√°ng k·ªÉ; **‚àí1**: k√©m h∆°n ƒë√°ng k·ªÉ.
  - **score** = t·ªïng h·ª£p c√≥ tr·ªçng s·ªë: **Value(0.22)**, **Quality(0.22)**, **Growth(0.20)**, **Momentum(0.20)**, **Liquidity(0.10)**, **Risk(0.06)**.
            """
        )

    # ---- K·∫øt lu·∫≠n ----
    st.subheader("‚úÖ K·∫øt lu·∫≠n (Top pick)")
    if ranked.empty:
        st.warning("Kh√¥ng c√≥ m√£ v∆∞·ª£t ng∆∞·ª°ng thanh kho·∫£n ho·∫∑c ƒë·ªß d·ªØ li·ªáu.")
    else:
        best = ranked.iloc[0]
        reasons = []
        for comp in ("Value","Quality","Growth","Momentum","Liquidity","RiskAdj"):
            val = best.get(comp, np.nan)
            if not pd.isna(val):
                reasons.append(f"{comp}={float(val):.2f}")
        sec = best.get("sector", "") or ""
        sec_txt = f" ¬∑ Sector: {sec}" if sec else ""
        st.success(f"**{best['symbol']}** l√† m√£ ph√π h·ª£p nh·∫•t{sec_txt}. L√Ω do: " + "; ".join(reasons))

    if show_charts and not ranked.empty:
        st.subheader("üìä Bi·ªÉu ƒë·ªì & b·∫£ng l·ªãch s·ª≠ (ch·ªçn m√£)")

        top_syms = list(ranked["symbol"].head(min(10, len(ranked))))
        # L∆∞u top_syms ƒë·ªÉ s·ª≠ d·ª•ng trong auto-advance
        st.session_state["top_syms"] = top_syms
        if "selected_symbol" not in st.session_state:
            st.session_state["selected_symbol"] = top_syms[0]

        selected_from_top = st.radio(
            "Top 10 theo ƒëi·ªÉm:",
            options=top_syms,
            index=top_syms.index(st.session_state["selected_symbol"]) if st.session_state["selected_symbol"] in top_syms else 0,
            horizontal=True,
            key="sym_radio",
            help="Ch·ªçn nhanh m·ªôt m√£ trong Top 10 theo ƒëi·ªÉm."
        )
        st.session_state["selected_symbol"] = selected_from_top

        def _on_enter_symbol():
            s = st.session_state.get("manual_symbol_input", "").strip().upper()
            if s:
                st.session_state["selected_symbol"] = s

        st.text_input("Ho·∫∑c nh·∫≠p m√£ kh√°c r·ªìi nh·∫•n Enter:", value="", placeholder="V√≠ d·ª•: FPT",
                      key="manual_symbol_input", on_change=_on_enter_symbol)

        selected_symbol = st.session_state["selected_symbol"]
        px_sel = px_map.get(selected_symbol)
        if (px_sel is None) or px_sel.empty:
            try:
                price_sources = [store["sources"][0]] if store.get("sources") else ["TCBS"]
                px_sel = _get_quote_history_cached(selected_symbol, int(store["params"]["days"]), store["ed_str"], price_sources)
                st.session_state["screener_store"]["px_map"][selected_symbol] = px_sel
            except Exception:
                px_sel = pd.DataFrame()

        chart_title = f"{selected_symbol}"

        if px_sel is None or px_sel.empty:
            st.info("Kh√¥ng c√≥ d·ªØ li·ªáu gi√° ƒë·ªÉ v·∫Ω.")
        else:
            # Th√¥ng tin h∆∞·ªõng d·∫´n s·ª≠ d·ª•ng bi·ªÉu ƒë·ªì
            with st.expander("üí° H∆∞·ªõng d·∫´n t∆∞∆°ng t√°c v·ªõi bi·ªÉu ƒë·ªì", expanded=False):
                st.markdown("""
                **üéØ T√≠nh nƒÉng Auto-scaling tr·ª•c Y:**
                - ‚úÖ Tr·ª•c Y s·∫Ω **t·ª± ƒë·ªông co gi√£n** khi b·∫°n thay ƒë·ªïi kho·∫£ng th·ªùi gian
                - üîç S·ª≠ d·ª•ng c√°c n√∫t **1M, 3M, 6M, All** ƒë·ªÉ thay ƒë·ªïi range nhanh
                - üìä Tr·ª•c Y t·ª± ƒë·ªông t·ªëi ∆∞u hi·ªÉn th·ªã theo gi√° cao nh·∫•t/th·∫•p nh·∫•t trong kho·∫£ng ƒë√£ ch·ªçn
                - üñ±Ô∏è **Double-click** tr√™n bi·ªÉu ƒë·ªì ƒë·ªÉ reset v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu
                
                **üîç T√≠nh nƒÉng Zoom n√¢ng cao:**
                - üñ±Ô∏è **Cu·ªôn chu·ªôt** ƒë·ªÉ zoom in/out tr·ª±c ti·∫øp tr√™n bi·ªÉu ƒë·ªì
                - ‚ö° K√©o th·∫£ ƒë·ªÉ zoom v√πng c·ª• th·ªÉ
                - üìè S·ª≠ d·ª•ng range slider ·ªü d∆∞·ªõi ƒë·ªÉ ƒëi·ªÅu h∆∞·ªõng nhanh
                - üéõÔ∏è C√≥ th·ªÉ nh·∫≠p range tr·ª±c ti·∫øp v√†o c√°c √¥ input
                
                **üìà T∆∞∆°ng t√°c kh√°c:**
                - Hover ƒë·ªÉ xem th√¥ng tin chi ti·∫øt t·∫°i t·ª´ng ƒëi·ªÉm
                - Click v√†o legend ƒë·ªÉ ·∫©n/hi·ªán c√°c ƒë∆∞·ªùng k·ªπ thu·∫≠t
                - K√©o tr·ª•c ƒë·ªÉ pan (di chuy·ªÉn) bi·ªÉu ƒë·ªì
                """)

            fig = make_ohlcv_figure(
                px_sel, chart_title,
                default_months_view=3, right_pad_months=2, height=700,
                show_ma9=show_ma9, show_ma20=show_ma20, show_ma50=show_ma50, 
                show_ma200=show_ma200, show_bollinger=show_bollinger
            )
            
            # C·∫•u h√¨nh plotly ƒë·ªÉ c√≥ th·ªÉ t∆∞∆°ng t√°c t·ªët h∆°n
            plotly_config = {
                "displaylogo": False,
                "modeBarButtonsToRemove": ["lasso2d", "select2d", "autoScale2d"],
                "modeBarButtonsToAdd": ["resetScale2d"],
                "showTips": True,
                "displayModeBar": True,
                "responsive": True,
                "doubleClick": "reset+autosize",  # Double click ƒë·ªÉ reset v·ªÅ auto-scale
                "scrollZoom": True,  # B·∫≠t zoom b·∫±ng cu·ªôn chu·ªôt
                "showAxisDragHandles": True,  # Hi·ªÉn th·ªã handles ƒë·ªÉ k√©o tr·ª•c
                "showAxisRangeEntryBoxes": True  # Hi·ªÉn th·ªã box ƒë·ªÉ nh·∫≠p range tr·ª±c ti·∫øp
            }
            
            st.plotly_chart(fig, use_container_width=True, config=plotly_config)

            st.markdown("**üìú L·ªãch s·ª≠ gi√° (g·∫ßn nh·∫•t)**")
            
            # Format d·ªØ li·ªáu ƒë·ªÉ hi·ªÉn th·ªã ƒë·∫πp
            px_display = px_sel.sort_values("date", ascending=False).head(120).copy()
            
            # Format ng√†y theo ki·ªÉu dd/mm/yyyy
            if "date" in px_display.columns:
                px_display["date"] = pd.to_datetime(px_display["date"]).dt.strftime("%d/%m/%Y")
            
            # Format volume v·ªõi d·∫•u ph·∫©y ngƒÉn c√°ch h√†ng ngh√¨n
            if "volume" in px_display.columns:
                px_display["volume"] = px_display["volume"].apply(
                    lambda x: f"{int(x):,}" if pd.notna(x) and x > 0 else "0"
                )
            
            # Format c√°c c·ªôt gi√° v·ªõi 2 ch·ªØ s·ªë th·∫≠p ph√¢n
            price_cols = ["open", "high", "low", "close"]
            for col in price_cols:
                if col in px_display.columns:
                    px_display[col] = px_display[col].apply(
                        lambda x: f"{float(x):,.2f}" if pd.notna(x) else "N/A"
                    )
            
            # Format gi√° tr·ªã giao d·ªãch n·∫øu c√≥
            if "value" in px_display.columns:
                px_display["value"] = px_display["value"].apply(
                    lambda x: f"{int(x):,}" if pd.notna(x) and x > 0 else "0"
                )
            
            # Column config cho b·∫£ng l·ªãch s·ª≠ gi√°
            price_column_config = {
                "date": cc.TextColumn("Ng√†y"),
                "open": cc.TextColumn("M·ªü c·ª≠a"),
                "high": cc.TextColumn("Cao nh·∫•t"),
                "low": cc.TextColumn("Th·∫•p nh·∫•t"),
                "close": cc.TextColumn("ƒê√≥ng c·ª≠a"),
                "volume": cc.TextColumn("Kh·ªëi l∆∞·ª£ng"),
                "value": cc.TextColumn("Gi√° tr·ªã")
            }
            st.dataframe(px_display, use_container_width=True, height=320, column_config=price_column_config)

            # ====== üìÑ B√°o c√°o theo FORM k·ªπ thu·∫≠t (MA20/50/200) ======
            st.markdown("---")
            
            # Quick Symbol Selector cho b√°o c√°o AI
            st.markdown("### üìÑ B√°o c√°o AI - Ph√¢n t√≠ch k·ªπ thu·∫≠t")
            
            # Hi·ªÉn th·ªã m√£ ƒëang ƒë∆∞·ª£c ph√¢n t√≠ch
            current_analyzing_symbol = st.session_state.get("selected_symbol", "")
            if current_analyzing_symbol:
                st.markdown(f"""
                <div style="background: linear-gradient(90deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%); 
                           padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #ff6b6b;">
                    <h4 style="margin: 0; color: #2c3e50;">
                        üîç ƒêang ph√¢n t√≠ch: <strong>{current_analyzing_symbol}</strong>
                    </h4>
                </div>
                """, unsafe_allow_html=True)
            
            # Hi·ªÉn th·ªã ti·∫øn tr√¨nh b√°o c√°o AI
            store = st.session_state.get("screener_store", {})
            if store:
                ranked = store.get("ranked", pd.DataFrame())
                if not ranked.empty:
                    top_syms = ranked.head(20)["symbol"].tolist()
                    cached_reports = st.session_state.get("form_cache", {})
                    reports_count = len([s for s in top_syms if s in cached_reports])
                    total_count = len(top_syms)
                    progress_pct = (reports_count / total_count) * 100 if total_count > 0 else 0
                    
                    st.markdown(f"""
                    <div style="background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%); 
                               padding: 12px; border-radius: 6px; margin-bottom: 15px;">
                        <p style="margin: 0; color: white; font-weight: bold;">
                            üìä Ti·∫øn tr√¨nh b√°o c√°o AI: {reports_count}/{total_count} ({progress_pct:.0f}%)
                        </p>
                    </div>
                    """, unsafe_allow_html=True)
            
            # T·∫°o container c√≥ border ƒë·ªÉ l√†m n·ªïi b·∫≠t
            with st.container(border=True):
                st.markdown("**üéØ Ch·ªçn m√£ c·ªï phi·∫øu ƒë·ªÉ xem b√°o c√°o AI:**")
                
                # Th√™m quick bookmarks cho c√°c m√£ th∆∞·ªùng xem
                if "ai_bookmarks" not in st.session_state:
                    st.session_state["ai_bookmarks"] = []
                
                bookmarks = st.session_state["ai_bookmarks"]
                if bookmarks:
                    st.markdown("**‚≠ê M√£ ƒë√£ ƒë√°nh d·∫•u:**")
                    bookmark_cols = st.columns(min(len(bookmarks), 6))
                    for i, bookmark in enumerate(bookmarks[:6]):  # Gi·ªõi h·∫°n 6 bookmark hi·ªÉn th·ªã
                        with bookmark_cols[i]:
                            cached_reports = st.session_state.get("form_cache", {})
                            status_emoji = "‚úÖ" if bookmark in cached_reports else "‚è≥"
                            if st.button(f"{status_emoji} {bookmark}", key=f"bookmark_{bookmark}", 
                                       use_container_width=True, help=f"Chuy·ªÉn ƒë·∫øn {bookmark}"):
                                st.session_state["selected_symbol"] = bookmark
                                st.rerun()
                
                col_quick1, col_quick2 = st.columns([2, 1])
                
                with col_quick1:
                    # Quick selector t·ª´ top symbols
                    cached_reports = st.session_state.get("form_cache", {})
                    
                    # T·∫°o danh s√°ch v·ªõi b√°o c√°o c√≥ s·∫µn ·ªü ƒë·∫ßu
                    symbols_with_reports = [s for s in top_syms if s in cached_reports]
                    symbols_without_reports = [s for s in top_syms if s not in cached_reports]
                    ordered_symbols = symbols_with_reports + symbols_without_reports
                    
                    # Hi·ªÉn th·ªã tr·∫°ng th√°i b√°o c√°o trong selectbox options
                    symbol_options = []
                    for sym in ordered_symbols:
                        if sym in cached_reports:
                            symbol_options.append(f"‚úÖ {sym}")
                        else:
                            symbol_options.append(f"‚è≥ {sym}")
                    
                    # T√¨m index hi·ªán t·∫°i
                    current_symbol = st.session_state.get("selected_symbol", ordered_symbols[0] if ordered_symbols else "")
                    try:
                        if current_symbol in cached_reports:
                            current_index = symbol_options.index(f"‚úÖ {current_symbol}")
                        else:
                            current_index = symbol_options.index(f"‚è≥ {current_symbol}")
                    except ValueError:
                        current_index = 0
                    
                    selected_option = st.selectbox(
                        "Ch·ªçn m√£ t·ª´ danh s√°ch:",
                        options=symbol_options,
                        index=current_index,
                        key="ai_symbol_selector",
                        help="‚úÖ = ƒê√£ c√≥ b√°o c√°o AI, ‚è≥ = Ch∆∞a c√≥ b√°o c√°o"
                    )
                    
                    # C·∫≠p nh·∫≠t selected_symbol t·ª´ quick selector
                    if selected_option:
                        new_symbol = selected_option.split(" ", 1)[1]  # L·∫•y ph·∫ßn sau emoji
                        if new_symbol != st.session_state.get("selected_symbol"):
                            st.session_state["selected_symbol"] = new_symbol
                            st.rerun()
                
                with col_quick2:
                    # Bookmark v√† manual input
                    bookmark_col, manual_col = st.columns([1, 3])
                    
                    current_idx = ordered_symbols.index(current_symbol) if current_symbol in ordered_symbols else 0
                    
                    with bookmark_col:
                        # Bookmark button
                        is_bookmarked = current_symbol in st.session_state.get("ai_bookmarks", [])
                        bookmark_icon = "‚≠ê" if is_bookmarked else "‚òÜ"
                        bookmark_help = "B·ªè ƒë√°nh d·∫•u" if is_bookmarked else "ƒê√°nh d·∫•u m√£ n√†y"
                        
                        if st.button(bookmark_icon, key="toggle_bookmark", help=bookmark_help):
                            if "ai_bookmarks" not in st.session_state:
                                st.session_state["ai_bookmarks"] = []
                            
                            if is_bookmarked:
                                st.session_state["ai_bookmarks"].remove(current_symbol)
                            else:
                                if current_symbol not in st.session_state["ai_bookmarks"]:
                                    st.session_state["ai_bookmarks"].append(current_symbol)
                                # Gi·ªõi h·∫°n s·ªë bookmark
                                if len(st.session_state["ai_bookmarks"]) > 10:
                                    st.session_state["ai_bookmarks"] = st.session_state["ai_bookmarks"][-10:]
                            st.rerun()
                    
                    with manual_col:
                        # Quick manual input
                        manual_symbol = st.text_input(
                            "Nh·∫≠p m√£ kh√°c:",
                            key="quick_manual_input",
                            placeholder="VD: VNM",
                            help="Nh·∫≠p m√£ v√† nh·∫•n Enter"
                        )
                        
                        # Auto-advance option
                        auto_advance = st.checkbox(
                            "üîÑ T·ª± ƒë·ªông chuy·ªÉn m√£ ti·∫øp theo", 
                            key="auto_advance_symbols",
                            help="T·ª± ƒë·ªông chuy·ªÉn ƒë·∫øn m√£ ti·∫øp theo sau 5 gi√¢y khi ƒë√£ c√≥ b√°o c√°o"
                        )
                    
                    if manual_symbol and manual_symbol.upper() != st.session_state.get("selected_symbol"):
                        st.session_state["selected_symbol"] = manual_symbol.upper()
                        st.rerun()
            
            # C·∫≠p nh·∫≠t l·∫°i selected_symbol v√† px_sel
            selected_symbol = st.session_state["selected_symbol"]
            px_sel = px_map.get(selected_symbol)
            if (px_sel is None) or px_sel.empty:
                try:
                    price_sources = [store["sources"][0]] if store.get("sources") else ["TCBS"]
                    px_sel = _get_quote_history_cached(selected_symbol, int(store["params"]["days"]), store["ed_str"], price_sources)
                    st.session_state["screener_store"]["px_map"][selected_symbol] = px_sel
                except Exception:
                    px_sel = pd.DataFrame()
            
            tech_stats = build_structured_stats(px_sel)

            # L·∫•y t√™n c√¥ng ty t·ª´ snapshot
            store = st.session_state.get("screener_store", {})
            snapshot_df = store.get("snapshot_df", pd.DataFrame())
            company_name = _company_name_from_snapshot(snapshot_df, selected_symbol)

            # Ki·ªÉm tra tr·∫°ng th√°i b√°o c√°o
            api_key = st.session_state.get("openai_api_key", "") or ""
            cached_reports = st.session_state.get("form_cache", {})
            has_report = selected_symbol in cached_reports
                
            # Hi·ªÉn th·ªã tr·∫°ng th√°i b√°o c√°o
            col_status, col_manual = st.columns([2, 1])
            
            with col_status:
                if not api_key:
                    st.info("üîë Nh·∫≠p OpenAI API Key ƒë·ªÉ s·ª≠ d·ª•ng t√≠nh nƒÉng ph√¢n t√≠ch t·ª± ƒë·ªông")
                elif has_report:
                    st.success("‚úÖ B√°o c√°o AI ƒë√£ c√≥ s·∫µn")
                else:
                    st.info("‚è≥ B√°o c√°o ch∆∞a ƒë∆∞·ª£c t·∫°o - ch·∫°y ph√¢n t√≠ch ƒë·ªÉ t·ª± ƒë·ªông t·∫°o b√°o c√°o")
            
            with col_manual:
                if api_key:
                    if st.button("üîÑ T·∫°o l·∫°i b√°o c√°o", key=f"regenerate_btn_{selected_symbol}", 
                               help="T·∫°o l·∫°i b√°o c√°o m·ªõi (ghi ƒë√® b√°o c√°o hi·ªán t·∫°i)"):
                        # X√≥a b√°o c√°o c≈© v√† t·∫°o m·ªõi
                        if "form_cache" in st.session_state and selected_symbol in st.session_state["form_cache"]:
                            del st.session_state["form_cache"][selected_symbol]
                        
                        key = st.session_state.get("openai_api_key", "") or ""
                        model = llm_model or "gpt-4o-mini"
                        template = st.session_state.get("analysis_template", "")
                        prompt = st.session_state.get("analysis_prompt", "")
                        system_prompt = st.session_state.get("system_prompt", "")
                        
                        with st.spinner("ü§ñ ƒêang t·∫°o b√°o c√°o m·ªõi..."):
                            report = call_llm_structured_report(
                                key, model, selected_symbol, tech_stats,
                                template=template, prompt=prompt, system_prompt=system_prompt, company_name=company_name
                            )
                            st.session_state.setdefault("form_cache", {})[selected_symbol] = report
                        st.rerun()
                else:
                    if st.button("üìù T·∫°o b√°o c√°o th·ªß c√¥ng", key=f"manual_btn_{selected_symbol}",
                               help="T·∫°o b√°o c√°o khi ch∆∞a c√≥ API key"):
                        st.warning("‚ö†Ô∏è C·∫ßn OpenAI API Key ƒë·ªÉ t·∫°o b√°o c√°o AI")

            form_text = (st.session_state.get("form_cache") or {}).get(selected_symbol)
            if form_text:
                # Hi·ªÉn th·ªã header v·ªõi m√£ v√† t√™n c√¥ng ty
                st.markdown(f"""
                        üìä Ph√¢n t√≠ch k·ªπ thu·∫≠t: {selected_symbol}
                """, unsafe_allow_html=True)
                
                st.markdown(form_text)
                st.download_button(
                    label="‚¨áÔ∏è T·∫£i b√°o c√°o (.txt)",
                    data="\ufeff" + form_text,
                    file_name=f"{selected_symbol}_PTKT_{store['ed_str']}.txt",
                    mime="text/plain; charset=utf-8"
                )
                
                # Auto-advance logic
                auto_advance = st.session_state.get("auto_advance_symbols", False)
                if auto_advance:
                    top_syms = st.session_state.get("top_syms", [])
                    current_symbol = selected_symbol
                    
                    # Ki·ªÉm tra xem t·∫•t c·∫£ c√°c m√£ ƒë√£ c√≥ b√°o c√°o ch∆∞a
                    cached_reports = st.session_state.get("form_cache", {})
                    symbols_with_reports = [sym for sym in top_syms if sym in cached_reports]
                    
                    if len(symbols_with_reports) >= len(top_syms):
                        st.success("üéâ ƒê√£ ho√†n th√†nh t·∫°o b√°o c√°o cho t·∫•t c·∫£ c√°c m√£ trong danh s√°ch!")
                    elif current_symbol in top_syms:
                        current_index = top_syms.index(current_symbol)
                        
                        # T√¨m m√£ ti·∫øp theo ch∆∞a c√≥ b√°o c√°o
                        next_symbol = None
                        for i in range(current_index + 1, len(top_syms)):
                            if top_syms[i] not in cached_reports:
                                next_symbol = top_syms[i]
                                break
                        
                        if next_symbol:
                            # Chuy·ªÉn ƒë·∫øn m√£ ti·∫øp theo sau 3 gi√¢y
                            # Ki·ªÉm tra xem ƒë√£ setup timer ch∆∞a
                            timer_key = f"auto_advance_timer_{current_symbol}"
                            if timer_key not in st.session_state:
                                st.session_state[timer_key] = time.time()
                                st.info(f"üîÑ S·∫Ω t·ª± ƒë·ªông chuy·ªÉn ƒë·∫øn m√£ **{next_symbol}** sau 3 gi√¢y...")
                                time.sleep(0.5)
                                st.rerun()
                            elif time.time() - st.session_state[timer_key] >= 3:
                                # ƒê√£ ƒë·ªß 3 gi√¢y, chuy·ªÉn m√£
                                del st.session_state[timer_key]
                                st.session_state["selected_symbol"] = next_symbol
                                st.success(f"üèÅ ƒê√£ chuy·ªÉn sang m√£ **{next_symbol}**!")
                                time.sleep(0.5)
                                st.rerun()
                            else:
                                # Hi·ªÉn th·ªã ƒë·∫øm ng∆∞·ª£c
                                remaining = 3 - (time.time() - st.session_state[timer_key])
                                st.info(f"üîÑ Chuy·ªÉn ƒë·∫øn m√£ **{next_symbol}** sau {remaining:.1f} gi√¢y...")
                                time.sleep(0.5)
                                st.rerun()
                        else:
                            st.success("ÔøΩ ƒê√£ ho√†n th√†nh t·∫°o b√°o c√°o cho t·∫•t c·∫£ c√°c m√£ trong danh s√°ch!")
                    else:
                        st.info("üèÅ M√£ hi·ªán t·∫°i kh√¥ng trong danh s√°ch ph√¢n t√≠ch!")
                        
            elif not api_key:
                st.info("üí° **ƒê·ªÉ s·ª≠ d·ª•ng t√≠nh nƒÉng b√°o c√°o AI:**\n"
                       "1. Nh·∫≠p OpenAI API Key ·ªü ph·∫ßn c·∫•u h√¨nh b√™n tr√°i\n"
                       "2. B√°o c√°o s·∫Ω ƒë∆∞·ª£c t·ª± ƒë·ªông t·∫°o cho m·ªói m√£ c·ªï phi·∫øu\n"
                       "3. C√≥ th·ªÉ t√πy ch·ªânh template v√† prompt ·ªü ph·∫ßn 'C·∫•u h√¨nh Prompt & Template AI'")
            else:
                if not has_report:
                    st.info("üîÑ Ch∆∞a c√≥ b√°o c√°o cho m√£ n√†y - ch·∫°y ph√¢n t√≠ch ƒë·ªÉ t·ª± ƒë·ªông t·∫°o")

            # ====== üì∞ C√¥ng b·ªë/ho·∫°t ƒë·ªông 7 ng√†y g·∫ßn ƒë√¢y (TCBS) ======
            st.markdown("### üì∞ C√¥ng b·ªë trong 7 ng√†y g·∫ßn ƒë√¢y (TCBS)")
            raw = fetch_activity_news_raw(selected_symbol, size=100)
            recent_items = filter_recent_activity_news(raw, recent_days=7)
            if not recent_items:
                st.markdown("_Kh√¥ng th·∫•y c√¥ng b·ªë trong 7 ng√†y g·∫ßn ƒë√¢y_")
            else:
                for it in recent_items:
                    ts_str = it["published_at"].strftime("%Y-%m-%d %H:%M")
                    src = it.get("source") or ""
                    title = it["title"]
                    st.markdown(f"- {ts_str} ¬∑ {src} ‚Äî {title}")

# ===== FOOTER =====
st.caption("(*) C√¥ng c·ª• s√†ng l·ªçc ƒë·ªãnh l∆∞·ª£ng mang t√≠nh tham kh·∫£o. Kh√¥ng ph·∫£i khuy·∫øn ngh·ªã ƒë·∫ßu t∆∞. K·∫øt h·ª£p th√™m ph√¢n t√≠ch ng√†nh, catalyst v√† qu·∫£n tr·ªã r·ªßi ro.")
