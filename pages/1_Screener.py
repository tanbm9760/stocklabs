# pages/1_Screener.py
from __future__ import annotations

import io
import time
from datetime import datetime, timedelta
from typing import Dict, List
import json
import sys
import os

import numpy as np
import pandas as pd
import streamlit as st
import plotly.graph_objects as go

# d√πng module adapter m·ªõi (singular)
from pick_best_by_symbols import VnAdapter, ScoreWeights, score_symbols, _calc_adtv_vnd

# Add utils to path
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

try:
    from utils.theme import set_page_config, apply_theme
    from utils.styling import load_css, create_section_header, create_metric_card
except ImportError:
    def set_page_config(title, icon):
        st.set_page_config(page_title=title, page_icon=icon, layout="wide")
    def apply_theme():
        pass
    def load_css():
        pass
    def create_section_header(title):
        return f"<h3>{title}</h3>"
    def create_metric_card(title, value, subtitle="", color="#2a5298"):
        return f"<div><h4>{title}</h4><h2>{value}</h2><small>{subtitle}</small></div>"

# ===== Optional deps for LLM & news =====
try:
    from openai import OpenAI
    _OPENAI_OK = True
except Exception:
    OpenAI = None
    _OPENAI_OK = False

try:
    import requests
except Exception:
    requests = None

# =========================
# Page config & Styling
# =========================
set_page_config("üìä Stock Screener", "üìä")
apply_theme()
load_css()

st.markdown("""
<div class="main-title">
    <h1 style="color: white !important; text-shadow: 0 2px 4px rgba(0,0,0,0.3);">üìä Stock Screener</h1>
    <p style="color: white !important; text-shadow: 0 1px 3px rgba(0,0,0,0.3);">C√¥ng c·ª• s√†ng l·ªçc v√† ch·∫•m ƒëi·ªÉm c·ªï phi·∫øu chuy√™n nghi·ªáp</p>
</div>
""", unsafe_allow_html=True)

# =========================
# Helpers
# =========================
def _prev_weekday(dt: datetime) -> datetime:
    while dt.weekday() >= 5:
        dt -= timedelta(days=1)
    return dt

def _parse_symbols_input(raw: str) -> List[str]:
    seen, out = set(), []
    for p in [x.strip().upper() for x in raw.split(",") if x.strip()]:
        if p not in seen:
            seen.add(p); out.append(p)
    return out

def _filter_company_tickers_only(symbols: List[str]) -> List[str]:
    """Ch·ªâ gi·ªØ m√£ 3 k√Ω t·ª± ch·ªØ c√°i (VD: FPT, VNM, HPG). Lo·∫°i ETF/CW/CCQ."""
    return [s for s in (symbols or []) if len(s) == 3 and s.isalpha()]

@st.cache_data(show_spinner=False, ttl=60*45)
def _get_quote_history_cached(symbol: str, days: int, end_date: str, sources: List[str]) -> pd.DataFrame:
    adapter = VnAdapter(preferred_sources=sources, end_date=end_date, verbose=False)
    return adapter.get_quote_history(symbol, days=days)

@st.cache_data(show_spinner=False, ttl=60*60)
def _get_screener_snapshot_cached(source: str = "TCBS") -> pd.DataFrame:
    """
    D√πng vnstock.Screener (n·∫øu c√≥) ch·ªâ ƒë·ªÉ l·∫•y sector ph·ª•c v·ª• sector-neutral scoring.
    Kh√¥ng d√πng c√°c s·ªë li·ªáu PE/PB/ROE‚Ä¶ ·ªü ƒë√¢y cho k·∫øt qu·∫£ ch√≠nh (ƒë√£ l·∫•y qua adapter.get_fundamentals).
    """
    try:
        adapter = VnAdapter(preferred_sources=[source], end_date=None, verbose=False)
        v = adapter.v
        Scr = getattr(v, "Screener", None)
        if Scr is None:
            return pd.DataFrame()
        scr = Scr(source=source)
        for meth in ("snapshot", "overview"):
            if hasattr(scr, meth):
                df = getattr(scr, meth)()
                if isinstance(df, pd.DataFrame) and not df.empty:
                    df.columns = [str(c).strip() for c in df.columns]
                    return df
    except Exception:
        pass
    return pd.DataFrame()

def _extract_sector_map_from_snapshot(snapshot_df: pd.DataFrame) -> Dict[str, str]:
    """Tr·∫£ v·ªÅ dict { 'FPT': 'Technology', ... } n·∫øu snapshot c√≥ c·ªôt ng√†nh."""
    if snapshot_df is None or snapshot_df.empty:
        return {}
    low = {c.lower(): c for c in snapshot_df.columns}
    sym_col = None
    for k in ("ticker", "symbol", "code"):
        if k in low:
            sym_col = low[k]; break
    if sym_col is None:
        return {}
    sector_col = None
    for k in ("sector", "industry", "icb_name", "industry_name", "sector_name"):
        if k in low:
            sector_col = low[k]; break
    if sector_col is None:
        return {}
    out = {}
    for _, r in snapshot_df.iterrows():
        sym = str(r[sym_col]).strip().upper()
        sec = str(r.get(sector_col, "")).strip()
        if sym and sec:
            out[sym] = sec
    return out

@st.cache_data(show_spinner=False, ttl=60*60)
def _get_fundamentals_precise_cached(symbol: str, source: str = "TCBS", period: str = "quarter") -> Dict[str, float]:
    """
    L·∫•y fundamentals qua adapter.get_fundamentals:
      - PE/PB/ROE/... t·ª´ finance.ratio(period)
      - rev_yoy t·ª´ **TCBS API** (yearRevenueGrowth, qu√Ω m·ªõi nh·∫•t)
      - C√°c tr∆∞·ªùng d·∫°ng % ƒë√£ ƒë∆∞·ª£c chu·∫©n ho√° th√†nh ƒë∆°n v·ªã ph·∫ßn trƒÉm trong adapter.
    """
    try:
        adapter = VnAdapter(preferred_sources=[source], end_date=None, verbose=False)
        return adapter.get_fundamentals(symbol, period=period)
    except Exception:
        return {}

def _annualized_vol(returns: pd.Series):
    d = returns.dropna()
    return d.std(ddof=0) * (252 ** 0.5) if len(d) > 1 else np.nan

def _safe_pct(a, b):
    try:
        if b == 0 or pd.isna(b): return np.nan
        return (float(a) - float(b)) / abs(float(b))
    except Exception:
        return np.nan

def compute_features_local_from_px(px: pd.DataFrame, fund: Dict) -> Dict:
    """T√≠nh m1/m3/m6, ADTV(20) t·ª´ d·ªØ li·ªáu gi√°; gh√©p th√™m fundamentals ƒë√£ chu·∫©n ho√° t·ª´ adapter."""
    if px is None or px.empty:
        base = {"m1": np.nan, "m3": np.nan, "m6": np.nan, "adtv": np.nan, "vol": np.nan}
        base.update(fund or {})
        return base

    p = px.copy()
    p["date"] = pd.to_datetime(p["date"])
    p = p.sort_values("date")

    def pct_change(days_back):
        if len(p) < days_back + 1: return np.nan
        return _safe_pct(p["close"].iloc[-1], p["close"].iloc[-(days_back + 1)])

    m1 = pct_change(21)
    m3 = pct_change(63)
    m6 = pct_change(126)

    # T√≠nh ADTV tr·ª±c ti·∫øp t·ª´ d·ªØ li·ªáu l·ªãch s·ª≠ (t·ªët h∆°n)
    adtv = _calc_adtv_from_history(p, n=20)
    vol = _annualized_vol(p["close"].pct_change())

    out = {"m1": m1, "m3": m3, "m6": m6, "adtv": adtv, "vol": vol}
    out.update(fund or {})
    return out

def _calc_adtv_from_history(px: pd.DataFrame, n: int = 20) -> float:
    """T√≠nh ADTV t·ª´ d·ªØ li·ªáu l·ªãch s·ª≠ gi√° c·∫£i ti·∫øn."""
    if px is None or px.empty:
        return np.nan
    
    # ƒê·∫£m b·∫£o c√≥ ƒë·ªß c·ªôt c·∫ßn thi·∫øt
    available_cols = set(px.columns)
    required_cols = {"close", "volume"}
    
    if not required_cols.issubset(available_cols):
        return np.nan
    
    # L·∫•y n phi√™n g·∫ßn nh·∫•t v√† l√†m s·∫°ch d·ªØ li·ªáu
    data = px.tail(n).copy()
    data["close_clean"] = pd.to_numeric(data["close"], errors="coerce")
    data["volume_clean"] = pd.to_numeric(data["volume"], errors="coerce")
    
    # Lo·∫°i b·ªè c√°c ng√†y c√≥ volume = 0 ho·∫∑c NaN (kh√¥ng giao d·ªãch)
    valid_data = data.dropna(subset=["close_clean", "volume_clean"])
    valid_data = valid_data[valid_data["volume_clean"] > 0]
    
    if len(valid_data) < 5:  # C·∫ßn √≠t nh·∫•t 5 phi√™n c√≥ giao d·ªãch
        return np.nan
    
    # T√≠nh gi√° tr·ªã giao d·ªãch trung b√¨nh
    # Gi√° t·ª´ vnstock: 41.10 ‚Üí 41,100 VND (nh√¢n 1000)
    # Volume: ƒë√£ ƒë√∫ng ƒë∆°n v·ªã (s·ªë c·ªï phi·∫øu)
    daily_value = valid_data["close_clean"] * 1000 * valid_data["volume_clean"]
    adtv = float(daily_value.mean())
    
    return adtv if not np.isnan(adtv) and adtv > 0 else np.nan

def _missing_bdays_to_break(dates: pd.Series) -> List[pd.Timestamp]:
    if dates.empty:
        return []
    d0 = pd.to_datetime(dates).sort_values()
    start = d0.min().normalize()
    end = d0.max().normalize()
    all_bdays = pd.bdate_range(start, end, freq="B")
    present = pd.to_datetime(d0.dt.normalize().unique())
    present_set = set(present)
    return [d for d in all_bdays if d not in present_set]

def _company_name_from_snapshot(snapshot_df: pd.DataFrame, symbol: str) -> str:
    if snapshot_df is None or snapshot_df.empty:
        return "‚Äî"
    low = {c.lower(): c for c in snapshot_df.columns}
    sym_col = None
    for k in ("ticker", "symbol", "code"):
        if k in low:
            sym_col = low[k]; break
    if sym_col is None:
        return "‚Äî"
    row = snapshot_df[sym_col].astype(str).str.upper() == symbol.upper()
    hit = snapshot_df[row]
    if hit.empty:
        return "‚Äî"
    name_candidates = [
        "organ_short_name", "organ_short_nm", "organ_name", "organname",
        "company_name", "companyName", "name", "org_name", "short_name"
    ]
    for cand in name_candidates:
        col = low.get(cand.lower())
        if col and col in hit.columns:
            val = str(hit.iloc[0][col]).strip()
            if val:
                return val
    return "‚Äî"

def make_ohlcv_figure(
    px: pd.DataFrame,
    title: str,
    *,
    default_months_view: int = 3,
    right_pad_months: int = 2,
    height: int = 700,
    vol_frac: float = 0.18,
    gap: float = 0.02,
    show_ma9: bool = True,
    show_ma20: bool = True,
    show_ma50: bool = False,
    show_ma200: bool = False,
    show_bollinger: bool = True,
) -> go.Figure:
    df = px.copy()
    df["date"] = pd.to_datetime(df["date"]); df = df.sort_values("date")
    missing_vals = _missing_bdays_to_break(df["date"])

    UP, DOWN = "#26a69a", "#ef5350"
    UP_A, DOWN_A = "rgba(38,166,154,0.85)", "rgba(239,83,80,0.85)"

    # T√≠nh to√°n SMA
    if show_ma9:
        df["ma9"] = df["close"].rolling(9, min_periods=1).mean()
    if show_ma20:
        df["ma20"] = df["close"].rolling(20, min_periods=1).mean()
    if show_ma50:
        df["ma50"] = df["close"].rolling(50, min_periods=1).mean()
    if show_ma200:
        df["ma200"] = df["close"].rolling(200, min_periods=1).mean()
        
    # T√≠nh to√°n Bollinger Bands
    if show_bollinger:
        bb_period = 20
        bb_multiplier = 2
        df["bb_middle"] = df["close"].rolling(bb_period, min_periods=1).mean()
        bb_std = df["close"].rolling(bb_period, min_periods=1).std()
        df["bb_upper"] = df["bb_middle"] + (bb_std * bb_multiplier)
        df["bb_lower"] = df["bb_middle"] - (bb_std * bb_multiplier)

    fig = go.Figure()
    
    # Th√™m Bollinger Bands tr∆∞·ªõc ƒë·ªÉ hi·ªÉn th·ªã ·ªü ph√≠a sau
    if show_bollinger:
        fig.add_trace(go.Scatter(
            x=df["date"], y=df["bb_upper"], 
            mode="lines", name="BB Upper",
            line=dict(color="rgba(156, 163, 175, 0.3)", width=1, dash="dash"),
            showlegend=False
        ))
        fig.add_trace(go.Scatter(
            x=df["date"], y=df["bb_lower"], 
            mode="lines", name="BB Lower",
            line=dict(color="rgba(156, 163, 175, 0.3)", width=1, dash="dash"),
            fill="tonexty", fillcolor="rgba(156, 163, 175, 0.1)",
            showlegend=False
        ))
    
    # Th√™m candlestick chart
    fig.add_trace(go.Candlestick(
        x=df["date"], open=df["open"], high=df["high"], low=df["low"], close=df["close"],
        name="Gi√°",
        increasing=dict(line=dict(color=UP, width=1), fillcolor=UP),
        decreasing=dict(line=dict(color=DOWN, width=1), fillcolor=DOWN),
        whiskerwidth=0,
        showlegend=True
    ))
    
    # Th√™m c√°c ƒë∆∞·ªùng SMA
    if show_ma9:
        fig.add_trace(go.Scatter(x=df["date"], y=df["ma9"], mode="lines", name="SMA9",
                                 line=dict(color="#f97316", width=1.2), showlegend=True))
    if show_ma20:
        fig.add_trace(go.Scatter(x=df["date"], y=df["ma20"], mode="lines", name="SMA20",
                                 line=dict(color="#f59e0b", width=1.4), showlegend=True))
    if show_ma50:
        fig.add_trace(go.Scatter(x=df["date"], y=df["ma50"], mode="lines", name="SMA50",
                                 line=dict(color="#60a5fa", width=1.4), showlegend=True))
    if show_ma200:
        fig.add_trace(go.Scatter(x=df["date"], y=df["ma200"], mode="lines", name="SMA200",
                                 line=dict(color="#a78bfa", width=1.6), showlegend=True))
    
    # Th√™m ƒë∆∞·ªùng Bollinger Middle (ch√≠nh l√† SMA20)
    if show_bollinger:
        fig.add_trace(go.Scatter(x=df["date"], y=df["bb_middle"], mode="lines", name="BB Middle",
                                 line=dict(color="#9ca3af", width=1.0, dash="dot"), showlegend=True))

    up = (df["close"] >= df["open"]).fillna(False)
    fig.add_trace(go.Bar(
        x=df["date"], y=df["volume"].fillna(0), name="Kh·ªëi l∆∞·ª£ng",
        marker_color=np.where(up, UP_A, DOWN_A), marker_line_width=0, opacity=0.95,
        yaxis="y2", showlegend=True
    ))

    x_end = df["date"].max()
    x_pad = x_end + pd.DateOffset(months=int(right_pad_months))
    x_start = x_end - pd.DateOffset(months=int(default_months_view))

    v = pd.to_numeric(df["volume"], errors="coerce").dropna()
    y2_max = None
    if len(v) > 0:
        q995 = float(np.percentile(v, 99.5)); med = float(np.median(v))
        y2_max = max(q995, med*3.0) * 1.10

    grid, axis, font = "#1f2937", "#374151", "#e5e7eb"
    paper = "#0b1220"; plot = "#0b1220"

    fig.update_layout(
        xaxis=dict(
            range=[x_start, x_pad],
            rangebreaks=[dict(bounds=["sat","mon"]), dict(values=missing_vals)],
            rangeslider=dict(visible=True, range=[df["date"].min(), x_pad],
                             thickness=0.12, bgcolor="#0f172a", bordercolor="#334155"),
            rangeselector=dict(
                y=0, yanchor="bottom", x=0.5, xanchor="center",
                bgcolor="#0b1220", activecolor="#1f2a44",
                buttons=[
                    dict(count=1, label="1M", step="month", stepmode="backward"),
                    dict(count=3, label="3M", step="month", stepmode="backward"),
                    dict(count=6, label="6M", step="month", stepmode="backward"),
                    dict(step="all", label="All")
                ],
            ),
            ticklabelposition="outside",
            showline=True, linewidth=1, linecolor=axis, gridcolor=grid, zeroline=False
        ),
        yaxis=dict(
            domain=[vol_frac + gap, 1.0],
            autorange=True,  # T·ª± ƒë·ªông scale theo d·ªØ li·ªáu hi·ªÉn th·ªã
            fixedrange=False,  # Cho ph√©p zoom/pan tr·ª•c Y
            showline=True, linewidth=1, linecolor=axis, gridcolor=grid, zeroline=False
        ),
        yaxis2=dict(
            domain=[0.0, vol_frac],
            rangemode="tozero", 
            autorange=True,  # T·ª± ƒë·ªông scale cho tr·ª•c volume
            fixedrange=False,  # Cho ph√©p zoom/pan tr·ª•c Y volume 
            tickformat="~s",
            showline=True, linewidth=1, linecolor=axis, gridcolor=grid, zeroline=False
        ),
        legend=dict(
            x=0.995, y=0.995, xanchor="right", yanchor="top",
            bgcolor="rgba(15,23,42,0.65)", bordercolor="#334155", borderwidth=1,
            font=dict(color=font, size=11),
            orientation="v",
            itemsizing="constant",
        ),
        title=dict(text=title, x=0.5, xanchor="center", font=dict(color="#ffffff", size=16)),
        hovermode="x unified",
        bargap=0.12, bargroupgap=0.0,
        margin=dict(l=6, r=6, t=52, b=10),
        paper_bgcolor=paper, plot_bgcolor=plot,
        font=dict(color=font),
        hoverlabel=dict(bgcolor="#0f172a", font_color=font, bordercolor=axis),
        height=height,
        # Th√™m c·∫•u h√¨nh ƒë·ªÉ t·ªëi ∆∞u h√≥a t∆∞∆°ng t√°c
        dragmode="zoom",  # Cho ph√©p zoom khi k√©o
        selectdirection="h",  # Ch·ªâ zoom theo chi·ªÅu ngang (h = horizontal)
        # Th√™m scroll zoom ƒë·ªÉ c√≥ th·ªÉ zoom b·∫±ng cu·ªôn chu·ªôt
        xaxis_fixedrange=False,  # Cho ph√©p zoom tr·ª•c X
        yaxis_fixedrange=False   # Cho ph√©p zoom tr·ª•c Y
    )
    
    return fig


# ======== TCBS Activities News helpers ========
@st.cache_data(show_spinner=False, ttl=600)
def fetch_activity_news_raw(symbol: str, page: int = 0, size: int = 100) -> Dict:
    """G·ªçi API TCBS activities ƒë·ªÉ l·∫•y danh s√°ch c√¥ng b·ªë/ho·∫°t ƒë·ªông theo m√£."""
    if requests is None:
        return {}
    url = "https://apipubaws.tcbs.com.vn/tcanalysis/v1/news/activities"
    params = {"fData": symbol, "fType": "tickers", "page": int(page), "size": int(size)}
    headers = {"User-Agent": "Mozilla/5.0 (compatible; StockApp/1.0)"}
    try:
        r = requests.get(url, params=params, headers=headers, timeout=10)
        r.raise_for_status()
        return r.json()
    except Exception:
        return {}

def filter_recent_activity_news(payload: Dict, recent_days: int = 7) -> List[Dict]:
    """L·ªçc danh s√°ch news, ch·ªâ l·∫•y trong v√≤ng `recent_days` g·∫ßn nh·∫•t."""
    items = (payload or {}).get("listActivityNews", []) or []
    cutoff = pd.Timestamp.today() - pd.Timedelta(days=int(recent_days))
    out: List[Dict] = []
    for it in items:
        try:
            ts = pd.to_datetime(it.get("publishDate"), errors="coerce")
        except Exception:
            ts = pd.NaT
        if pd.isna(ts):
            continue
        if ts >= cutoff:
            out.append({
                "ticker": it.get("ticker"),
                "title": (it.get("title") or "").strip(),
                "source": it.get("source"),
                "published_at": ts,
            })
    out.sort(key=lambda x: x["published_at"], reverse=True)
    return out


# ======== Indicators / stats for FORM ========
def _rsi(series: pd.Series, n: int = 14) -> pd.Series:
    s = series.astype(float)
    delta = s.diff()
    up = delta.clip(lower=0).rolling(n).mean()
    down = (-delta.clip(upper=0)).rolling(n).mean()
    rs = up / down.replace(0, np.nan)
    return 100 - (100 / (1 + rs))

def _atr_df(df: pd.DataFrame, n: int = 14) -> pd.Series:
    d = df.copy()
    d["prev_close"] = d["close"].shift(1)
    tr = pd.concat([
        (d["high"] - d["low"]).abs(),
        (d["high"] - d["prev_close"]).abs(),
        (d["low"]  - d["prev_close"]).abs()
    ], axis=1).max(axis=1)
    return tr.rolling(n).mean()

def _slope(arr: pd.Series, lookback: int = 5) -> float:
    y = pd.to_numeric(arr.tail(lookback), errors="coerce").dropna()
    if len(y) < 3:
        return np.nan
    x = np.arange(len(y), dtype=float)
    A = np.vstack([x, np.ones(len(x))]).T
    m, _ = np.linalg.lstsq(A, y, rcond=None)[0]
    return float(m)

def _pivot_levels(df: pd.DataFrame, win_high: int = 20, win_low: int = 20):
    d = df.copy().tail(max(win_high, win_low) + 5)
    res = float(d["high"].rolling(win_high, min_periods=1).max().iloc[-2])
    sup = float(d["low"].rolling(win_low, min_periods=1).min().iloc[-2])
    return res, sup

def build_structured_stats(px: pd.DataFrame) -> dict:
    p = px.copy()
    p["date"] = pd.to_datetime(p["date"])
    p = p.sort_values("date").reset_index(drop=True)

    last_close = float(p["close"].iloc[-1])
    last_date  = p["date"].iloc[-1].strftime("%Y-%m-%d")

    # Ch·ªâ MA20/50/200
    for w in (20, 50, 200):
        p[f"ma{w}"] = p["close"].rolling(w).mean()

    def rr(days):
        return float((p["close"].iloc[-1] / p["close"].iloc[max(0, len(p)-1-days)] - 1) * 100) if len(p) > days else np.nan
    r1m, r3m, r6m = rr(21), rr(63), rr(126)

    rsi14 = float(_rsi(p["close"], 14).iloc[-1])
    atr14 = _atr_df(p, 14).iloc[-1]
    atr_pct = float((atr14 / last_close) * 100) if pd.notna(atr14) else np.nan
    adtv_vnd = float((p["close"].tail(20) * 1000 * p["volume"].tail(20)).mean()) if "volume" in p else np.nan

    win = min(252, len(p))
    hi_52w = float(p["high"].tail(win).max())
    lo_52w = float(p["low"].tail(win).min())

    slope_ma20  = _slope(p["ma20"], 5)
    slope_ma50  = _slope(p["ma50"], 5)
    slope_ma200 = _slope(p["ma200"], 10)

    vol_mean_20 = float(p["volume"].tail(20).mean())
    vol_mean_60 = float(p["volume"].tail(60).mean())
    vol_trend = "tƒÉng" if vol_mean_20 > vol_mean_60 * 1.1 else ("gi·∫£m" if vol_mean_20 < vol_mean_60 * 0.9 else "ƒëi ngang")

    res_piv, sup_piv = _pivot_levels(p, 20, 20)
    levels = {
        "kh√°ng_c·ª±_g·∫ßn": res_piv,
        "h·ªó_tr·ª£_g·∫ßn": sup_piv,
        "ma20": float(p["ma20"].iloc[-1]) if not pd.isna(p["ma20"].iloc[-1]) else np.nan,
        "ma50": float(p["ma50"].iloc[-1]) if not pd.isna(p["ma50"].iloc[-1]) else np.nan,
        "ma200": float(p["ma200"].iloc[-1]) if not pd.isna(p["ma200"].iloc[-1]) else np.nan,
        "hi_52w": hi_52w, "lo_52w": lo_52w
    }

    return {
        "last_date": last_date, "last_close": last_close,
        "ret_1m_%": r1m, "ret_3m_%": r3m, "ret_6m_%": r6m,
        "rsi14": rsi14, "atr14_%": atr_pct,
        "adtv_20_vnd": adtv_vnd,
        "slopes": {"ma20": slope_ma20, "ma50": slope_ma50, "ma200": slope_ma200},
        "levels": levels,
        "vol_trend": vol_trend
    }

def call_llm_structured_report(api_key: str, model: str, symbol: str, tech_stats: dict) -> str:
    if not _OPENAI_OK or not api_key:
        return "‚õî Ch∆∞a c·∫•u h√¨nh OpenAI API key."

    TEMPLATE = (
        "PH√ÇN T√çCH K·ª∏ THU·∫¨T\n\n"
        "1. Xu h∆∞·ªõng gi√°:\n- ...\n- ...\n- ...\n\n"
        "2. ƒê∆∞·ªùng MA (20/50/200):\n- MA20: ...\n- MA50: ...\n- MA200: ...\n\n"
        "3. Kh·ªëi l∆∞·ª£ng:\n- ...\n- ...\n\n"
        "4. H·ªó tr·ª£ & Kh√°ng c·ª±:\n- Kh√°ng c·ª±: ...\n- H·ªó tr·ª£ g·∫ßn: ...\n- H·ªó tr·ª£ s√¢u: ...\n\n"
        "NH·∫¨N ƒê·ªäNH NHANH & CHI·∫æN L∆Ø·ª¢C\n\n"
        "- Ng·∫Øn h·∫°n: ...\n- Trung h·∫°n: ...\n\n"
        "Chi·∫øn l∆∞·ª£c:\n- L∆∞·ªõt s√≥ng: ...\n- Trung h·∫°n: ..."
    )

    guidance = (
        "B·∫°n l√† chuy√™n gia PTKT c·ªï phi·∫øu Vi·ªát Nam. D·ª±a **duy nh·∫•t** v√†o d·ªØ li·ªáu cung c·∫•p, "
        "h√£y vi·∫øt b√°o c√°o ƒë√∫ng **form m·∫´u** (ti·∫øng Vi·ªát, ng·∫Øn g·ªçn). Ch·ªâ ƒë√°nh gi√° MA20/MA50/MA200.\n\n"
        f"{TEMPLATE}\n\n"
        "- 'ƒê∆∞·ªùng MA' n√™u h∆∞·ªõng (l√™n/xu·ªëng/ƒëi ngang) + vai tr√≤ (h·ªó tr·ª£/kh√°ng c·ª±) theo ƒë·ªô d·ªëc & v·ªã tr√≠ gi√°.\n"
        "- 'Kh·ªëi l∆∞·ª£ng' so s√°nh trung b√¨nh 20 vs 60 phi√™n.\n"
        "- 'H·ªó tr·ª£ & Kh√°ng c·ª±' d·ª±a pivot g·∫ßn nh·∫•t, MA v√† 52W.\n"
        "- 'L∆∞·ªõt s√≥ng/Trung h·∫°n' c√≥ v√πng mua tham kh·∫£o, stoploss (~1‚Äì1.5√óATR%), m·ª•c ti√™u theo kh√°ng c·ª±/ƒë·ªânh c≈©.\n"
        "- ƒê·ªãnh d·∫°ng s·ªë c√≥ **d·∫•u ph·∫©y** (vd 31,000). Kh√¥ng coi ƒë√¢y l√† khuy·∫øn ngh·ªã ƒë·∫ßu t∆∞."
    )

    payload = {"symbol": symbol, **tech_stats}
    try:
        client = OpenAI(api_key=api_key)
        msgs = [
            {"role": "system", "content": "B·∫°n l√† chuy√™n gia ph√¢n t√≠ch k·ªπ thu·∫≠t c·ªï phi·∫øu Vi·ªát Nam, vi·∫øt k·ª∑ lu·∫≠t theo template."},
            {"role": "user", "content": guidance + "\n\nD·ªÆ LI·ªÜU:\n" + json.dumps(payload, ensure_ascii=False)}
        ]
        out = client.chat.completions.create(model=model, messages=msgs, temperature=0.15, max_tokens=1000)
        text = out.choices[0].message.content if out and out.choices else ""
        return text or "_Kh√¥ng c√≥ n·ªôi dung_"
    except Exception as e:
        return f"‚ùå L·ªói g·ªçi LLM: {e}"

# =========================
# Sidebar ‚Äî Watchlist Manager
# =========================
# Enhanced Sidebar - Simplified
# =========================
with st.sidebar:
    st.markdown("""
    <div class="section-header">
        <h3>üóÇÔ∏è Qu·∫£n l√Ω Watchlists</h3>
    </div>
    """, unsafe_allow_html=True)
    
    st.markdown("""
    <div class="control-panel" style="margin-top: 0;">
    """, unsafe_allow_html=True)

    # --- Kh·ªüi t·∫°o state ---
    if "watchlists" not in st.session_state:
        # M·∫∑c ƒë·ªãnh v√†i v√≠ d·ª•. B·∫°n c√≥ th·ªÉ s·ª≠a/ƒë·ªïi t√™n/ƒë·ªïi m√£ tr·ª±c ti·∫øp.
        st.session_state.watchlists = {
            "My Picks": ["FPT", "VNM", "HPG", "MWG", "SSI", "VCB"],
            "Banking": ["VCB", "CTG", "BID", "TCB", "VPB", "MBB", "TPB", "ACB", "STB", "EIB", "SHB"],
            "Bluechips": ["VIC", "VHM", "VRE", "VNM", "SAB", "PLX", "GAS", "FPT", "MWG", "HPG", "SSI", "VCB"],
        }
    if "current_watchlist" not in st.session_state:
        st.session_state.current_watchlist = "My Picks"

    # Hi·ªÉn th·ªã s·ªë l∆∞·ª£ng danh s√°ch
    total_lists = len(st.session_state.watchlists)
    total_symbols = sum(len(symbols) for symbols in st.session_state.watchlists.values())
    
    st.markdown(f"""
    <div class="metric-card">
        <strong>üìã {total_lists}</strong> danh s√°ch | <strong>üìà {total_symbols}</strong> m√£ c·ªï phi·∫øu
    </div>
    """, unsafe_allow_html=True)

    wl_names = sorted(st.session_state.watchlists.keys())
    if st.session_state.current_watchlist not in wl_names:
        wl_names = (wl_names + [st.session_state.current_watchlist]) if st.session_state.current_watchlist else wl_names
    

    # ƒê∆∞a ph·∫ßn ch·ªçn danh s√°ch ƒëang ph√¢n t√≠ch l√™n ƒë·∫ßu
    st.session_state.current_watchlist = st.selectbox(
        "üéØ ƒêang ph√¢n t√≠ch danh s√°ch",
        options=sorted(st.session_state.watchlists.keys()),
        index=sorted(st.session_state.watchlists.keys()).index(st.session_state.current_watchlist),
        key="active_watchlist_picker",
        help="Danh s√°ch n√†y s·∫Ω ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ ph√¢n t√≠ch khi nh·∫•n n√∫t Ph√¢n t√≠ch"
    )

    selected_wl = st.session_state.current_watchlist

    # Ch·ªçn danh s√°ch ƒë·ªÉ thao t√°c (·∫©n label)
    wl_names = sorted(st.session_state.watchlists.keys())
    new_wl_name = st.text_input(
        label="",
        value="",
        placeholder="T√™n danh s√°ch m·ªõi",
        key="new_wl_name_input",
        label_visibility="collapsed",
        help="Nh·∫≠p t√™n ƒë·ªÉ t·∫°o danh s√°ch m·ªõi"
    )

    # √î text ch·ªânh m√£ cho watchlist ƒëang ch·ªçn (·∫©n label)
    current_symbols_str = ", ".join(st.session_state.watchlists.get(selected_wl, []))
    edited_symbols_str = st.text_area(
        label="",
        value=current_symbols_str,
        key=f"wl_text_{selected_wl}",
        label_visibility="collapsed",
        help="V√≠ d·ª•: FPT, VNM, HPG, SSI (ch·ªâ ch·∫•p nh·∫≠n m√£ 3 k√Ω t·ª±)",
        height=100
    )

    st.markdown("</div>", unsafe_allow_html=True)

    # Action buttons ch·ªâ hi·ªán icon
    col_btn1, col_btn2, col_btn3 = st.columns([1, 1, 1])
    with col_btn1:
        if st.button("", use_container_width=True, help="L∆∞u danh s√°ch", key="save_btn", type="secondary", icon="üíæ"):
            cleaned = _filter_company_tickers_only(_parse_symbols_input(edited_symbols_str))
            st.session_state.watchlists[selected_wl] = cleaned
            st.success(f"‚úÖ ƒê√£ l∆∞u '{selected_wl}' ({len(cleaned)} m√£)")
    with col_btn2:
        if st.button("", use_container_width=True, help="T·∫°o danh s√°ch m·ªõi", key="create_btn", type="secondary", icon="‚ûï"):
            name = (new_wl_name or "").strip()
            if not name:
                st.warning("‚ö†Ô∏è Vui l√≤ng nh·∫≠p t√™n danh s√°ch")
            elif name in st.session_state.watchlists:
                st.warning("‚ö†Ô∏è T√™n ƒë√£ t·ªìn t·∫°i")
            else:
                cleaned = _filter_company_tickers_only(_parse_symbols_input(edited_symbols_str))
                st.session_state.watchlists[name] = cleaned
                st.session_state.current_watchlist = name
                st.success(f"‚úÖ ƒê√£ t·∫°o '{name}' ({len(cleaned)} m√£)")
    with col_btn3:
        if st.button("", use_container_width=True, help="X√≥a danh s√°ch", key="delete_btn", type="secondary", icon="üóëÔ∏è"):
            if selected_wl in st.session_state.watchlists:
                if len(st.session_state.watchlists) <= 1:
                    st.warning("‚ö†Ô∏è C·∫ßn √≠t nh·∫•t 1 danh s√°ch")
                else:
                    del st.session_state.watchlists[selected_wl]
                    st.session_state.current_watchlist = next(iter(st.session_state.watchlists.keys()))
                    st.success(f"‚úÖ ƒê√£ x√≥a '{selected_wl}'")

# =========================
# MAIN CONTENT - Quick Analysis Section
# =========================

# Quick Analysis Panel (·ªü ƒë·∫ßu)
col_main1, col_main2 = st.columns([2, 1])

with col_main1:
    # Hi·ªÉn th·ªã danh s√°ch ƒëang ch·ªçn
    active_wl_name = st.session_state.current_watchlist
    current_symbols = st.session_state.watchlists.get(active_wl_name, [])
    
    st.markdown(f"""
    <div class="metric-card" style="padding: 1rem; margin-bottom: 1rem;">
        <h4>üìÇ Danh s√°ch: {active_wl_name}</h4>
        <p><strong>{len(current_symbols)}</strong> m√£ c·ªï phi·∫øu: {', '.join(current_symbols[:10])}{' ...' if len(current_symbols) > 10 else ''}</p>
    </div>
    """, unsafe_allow_html=True)

with col_main2:
    # N√∫t ph√¢n t√≠ch ch√≠nh
    analyze_btn = st.button(
        "üöÄ B·∫Øt ƒë·∫ßu ph√¢n t√≠ch", 
        use_container_width=True,
        type="primary",
        help="Nh·∫•n ƒë·ªÉ b·∫Øt ƒë·∫ßu ph√¢n t√≠ch c√°c c·ªï phi·∫øu trong danh s√°ch"
    )

# Advanced Configuration (c√≥ th·ªÉ ·∫©n/hi·ªán)
with st.expander("‚öôÔ∏è C·∫•u h√¨nh n√¢ng cao", expanded=False):
    col_config1, col_config2 = st.columns(2)
    
    with col_config1:
        st.markdown("**üìä Tham s·ªë ph√¢n t√≠ch**")
        days = st.number_input(
            "üìÖ S·ªë ng√†y l·ªãch s·ª≠", 
            60, 1500, 360, 30, 
            help="S·ªë ng√†y d·ªØ li·ªáu gi√° ƒë·ªÉ ph√¢n t√≠ch (‚â•252 cho ƒë·ªß 52 tu·∫ßn)"
        )
        
        tminus = st.number_input(
            "‚è∞ L√πi ng√†y (T-n)", 
            0, 30, 0, 1,
            help="L√πi ng√†y k·∫øt th√∫c ƒë·ªÉ ph√¢n t√≠ch d·ªØ li·ªáu tr∆∞·ªõc ƒë√≥"
        )
        
        end_date = st.text_input(
            "üìÖ Ng√†y k·∫øt th√∫c", 
            value="",
            placeholder="YYYY-MM-DD ho·∫∑c ƒë·ªÉ tr·ªëng",
            help="Ng√†y k·∫øt th√∫c ph√¢n t√≠ch (m·∫∑c ƒë·ªãnh: h√¥m nay)"
        )

    with col_config2:
        st.markdown("**ü§ñ C·∫•u h√¨nh AI**")
        api_key_default = st.session_state.get("openai_api_key", "")
        api_key_input = st.text_input(
            "üîë OpenAI API Key", 
            value=api_key_default, 
            type="password",
            help="API key ƒë·ªÉ t·∫°o b√°o c√°o ph√¢n t√≠ch b·∫±ng AI"
        )
        if api_key_input:
            st.session_state["openai_api_key"] = api_key_input
        
        llm_model = st.text_input(
            "üß† Model AI", 
            value="gpt-4o-mini",
            help="M√¥ h√¨nh AI ƒë·ªÉ t·∫°o b√°o c√°o"
        )
        
        polite_delay_ms = st.slider(
            "‚è±Ô∏è ƒê·ªô tr·ªÖ API (ms)", 
            0, 1000, 300, 50,
            help="Th·ªùi gian ch·ªù gi·ªØa c√°c l·ªánh g·ªçi API"
        )

# =========================
# Resolve dates & symbols with default values
# =========================
# Set default values for removed variables
max_symbols = 200  # Kh√¥ng gi·ªõi h·∫°n s·ªë m√£
min_adtv = 0  # Kh√¥ng l·ªçc thanh kho·∫£n
sources_str = "TCBS"  # Ngu·ªìn m·∫∑c ƒë·ªãnh
show_charts = True  # Lu√¥n hi·ªÉn th·ªã bi·ªÉu ƒë·ªì
show_ma9 = True  # SMA9 m·∫∑c ƒë·ªãnh hi·ªÉn th·ªã
show_ma20 = True  # SMA20 m·∫∑c ƒë·ªãnh hi·ªÉn th·ªã
show_ma50 = True  # SMA50 m·∫∑c ƒë·ªãnh hi·ªÉn th·ªã
show_ma200 = True  # SMA200 m·∫∑c ƒë·ªãnh hi·ªÉn th·ªã
show_bollinger = True  # Bollinger Bands m·∫∑c ƒë·ªãnh hi·ªÉn th·ªã

# L·∫•y gi√° tr·ªã t·ª´ config ho·∫∑c d√πng m·∫∑c ƒë·ªãnh
if 'days' not in locals():
    days = 360
if 'tminus' not in locals():
    tminus = 0
if 'end_date' not in locals():
    end_date = ""
if 'polite_delay_ms' not in locals():
    polite_delay_ms = 300

if tminus and tminus > 0:
    ed = _prev_weekday(datetime.today() - timedelta(days=int(tminus)))
else:
    ed = _prev_weekday(datetime.today())
    if end_date.strip():
        try:
            ed = _prev_weekday(pd.to_datetime(end_date))
        except Exception:
            st.warning("Ng√†y k·∫øt th√∫c kh√¥ng h·ª£p l·ªá, d√πng ng√†y l√†m vi·ªác g·∫ßn nh·∫•t.")
ed_str = ed.strftime("%Y-%m-%d")
sources = [s.strip().upper() for s in (sources_str or "TCBS").split(",") if s.strip()]

# L·∫•y m√£ t·ª´ watchlist ƒëang ch·ªçn
active_wl_name = st.session_state.current_watchlist
symbols_all = _filter_company_tickers_only(st.session_state.watchlists.get(active_wl_name, []))
symbols = symbols_all[:max_symbols]
if len(symbols_all) > len(symbols):
    st.info(f"ƒê√£ gi·ªõi h·∫°n {len(symbols)}/{len(symbols_all)} m√£ ƒë·ªÉ tr√°nh rate-limit.")

# =========================
# Main: run analysis once & store
# =========================
def run_analysis_and_store():
    if not symbols:
        st.error("Danh s√°ch hi·ªán tr·ªëng ho·∫∑c kh√¥ng c√≥ m√£ h·ª£p l·ªá (3 k√Ω t·ª± ch·ªØ c√°i).")
        return

    st.info(f"ƒêang ph√¢n t√≠ch **{len(symbols)}** m√£ t·ª´ watchlist **{active_wl_name}** ¬∑ days={days} ¬∑ end={ed_str} ¬∑ sources={sources}")

    primary_source_for_fund = sources[0] if sources else "TCBS"
    snap_df = _get_screener_snapshot_cached(primary_source_for_fund)  # ch·ªâ ƒë·ªÉ l·∫•y sector n·∫øu c√≥
    sector_map = _extract_sector_map_from_snapshot(snap_df)  # c√≥ th·ªÉ r·ªóng n·∫øu kh√¥ng l·∫•y ƒë∆∞·ª£c

    rows_feat: List[Dict] = []
    px_map: Dict[str, pd.DataFrame] = {}

    try:
        prog = st.progress(0, text="Ch∆∞a b·∫Øt ƒë·∫ßu")
        prog_text = None
    except TypeError:
        prog = st.progress(0)
        prog_text = st.empty()

    price_sources = [sources[0]] if sources else ["TCBS"]

    for i, sym in enumerate(symbols, 1):
        label = f"ƒêang t·∫£i d·ªØ li·ªáu {i}/{len(symbols)} - {sym}"
        try:
            prog.progress(i/len(symbols), text=label)
        except TypeError:
            prog.progress(i/len(symbols))
            if prog_text: prog_text.markdown(f"**{label}**")

        # Gi√°
        try:
            px = _get_quote_history_cached(sym, int(days), ed_str, price_sources)
        except Exception:
            px = pd.DataFrame()
        px_map[sym] = px

        # Fundamentals (rev_yoy t·ª´ TCBS API ‚Äì x·ª≠ l√Ω trong adapter)
        fund_precise = _get_fundamentals_precise_cached(sym, source=primary_source_for_fund, period="quarter")

        # T√≠nh features t·ª´ px + fund
        feat = {"symbol": sym}
        feat.update(compute_features_local_from_px(px, fund_precise))
        rows_feat.append(feat)

        if polite_delay_ms > 0:
            time.sleep(polite_delay_ms / 1000.0)

    df_feat = pd.DataFrame(rows_feat)

    # Th√™m sector (n·∫øu c√≥)
    if not df_feat.empty:
        df_feat["sector"] = df_feat["symbol"].map(lambda s: sector_map.get(str(s).upper(), ""))

    # B·∫£o ƒë·∫£m c√°c c·ªôt c√≥ t·ªìn t·∫°i
    for col in ["pe","pb","roe","net_margin","de","rev_yoy","eps_yoy","m1","m3","m6","adtv","vol"]:
        if col not in df_feat.columns:
            df_feat[col] = np.nan
        if df_feat[col].notna().sum() == 0:
            df_feat[col] = 0.0

    ranked = score_symbols(df_feat, ScoreWeights(), min_adtv=float(min_adtv))

    st.session_state["screener_store"] = {
        "ranked": ranked, "df_feat": df_feat, "px_map": px_map,
        "ed_str": ed_str, "sources": sources, "params": dict(days=days, min_adtv=min_adtv),
        "snapshot_df": snap_df,
        "active_watchlist": active_wl_name,
    }
    if "form_cache" not in st.session_state:
        st.session_state["form_cache"] = {}

if analyze_btn:
    with st.spinner("üîÑ ƒêang ph√¢n t√≠ch d·ªØ li·ªáu..."):
        run_analysis_and_store()

# =========================
# Enhanced Results Display
# =========================
store = st.session_state.get("screener_store")

if store is None:
    st.markdown("""
    <div class="metric-card" style="text-align: center; padding: 2rem;">
        <h4>üëã Ch√†o m·ª´ng ƒë·∫øn v·ªõi Stock Screener</h4>
        <p>Vui l√≤ng ch·ªçn danh s√°ch c·ªï phi·∫øu trong sidebar v√† nh·∫•n n√∫t <strong>üöÄ B·∫Øt ƒë·∫ßu ph√¢n t√≠ch</strong> ƒë·ªÉ b·∫Øt ƒë·∫ßu.</p>
        <br>
        <div class="status-indicator status-warning"></div>
        <small>Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ hi·ªÉn th·ªã</small>
    </div>
    """, unsafe_allow_html=True)
else:
    ranked = store["ranked"]; px_map = store["px_map"]
    
    # Summary metrics
    total_analyzed = len(ranked)
    avg_score = ranked['score'].mean() if 'score' in ranked.columns else 0
    top_performer = ranked.iloc[0]['symbol'] if len(ranked) > 0 else "N/A"
    
    st.markdown(f"""
    <div class="section-header">
        <h3>üèÜ K·∫øt qu·∫£ ph√¢n t√≠ch - {store.get('active_watchlist','Danh s√°ch')}</h3>
    </div>
    """, unsafe_allow_html=True)
    
    # Summary cards
    col1, col2, col3, col4 = st.columns(4)
    with col1:
        st.markdown(f"""
        <div class="metric-card">
            <h4>üìä T·ªïng s·ªë m√£</h4>
            <h2 style="color: #2a5298;">{total_analyzed}</h2>
            <small>C·ªï phi·∫øu ƒë√£ ph√¢n t√≠ch</small>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown(f"""
        <div class="metric-card">
            <h4>‚≠ê ƒêi·ªÉm trung b√¨nh</h4>
            <h2 style="color: #2a5298;">{avg_score:.2f}</h2>
            <small>ƒêi·ªÉm s·ªë t·ªïng h·ª£p</small>
        </div>
        """, unsafe_allow_html=True)
    
    with col3:
        st.markdown(f"""
        <div class="metric-card">
            <h4>ü•á Top performer</h4>
            <h2 style="color: #28a745;">{top_performer}</h2>
            <small>C·ªï phi·∫øu t·ªët nh·∫•t</small>
        </div>
        """, unsafe_allow_html=True)
    
    with col4:
        analyzed_date = store.get('ed_str', 'N/A')
        st.markdown(f"""
        <div class="metric-card">
            <h4>üìÖ Ng√†y ph√¢n t√≠ch</h4>
            <h2 style="color: #2a5298; font-size: 1.2rem;">{analyzed_date}</h2>
            <small>D·ªØ li·ªáu ƒë·∫øn ng√†y</small>
        </div>
        """, unsafe_allow_html=True)

    st.markdown("<br>", unsafe_allow_html=True)
    
    # Enhanced ranking table
    st.markdown("""
    <div class="section-header">
        <h4>üìã B·∫£ng x·∫øp h·∫°ng chi ti·∫øt</h4>
    </div>
    """, unsafe_allow_html=True)
    
    view = ranked.copy()

    # ---- format helpers ----
    def pct_return(x):  # m1/m3/m6 l√† t·ªâ l·ªá (0.123)
        return "" if pd.isna(x) else f"{x*100.0:.1f}%"

    def pct_ready(x):   # ƒë√£ l√† % (vd 29.7)
        return "" if pd.isna(x) else f"{x:.1f}%"

    # Score & component scores
    for c in ("score","Value","Quality","Growth","Momentum","Liquidity","RiskAdj","pe","pb"):
        if c in view.columns:
            view[c] = view[c].apply(lambda x: "" if pd.isna(x) else (f"{x:.3f}" if c=="score" else f"{x:.2f}"))

    # Returns: m1/m3/m6 (t·ªâ l·ªá ‚Üí *100 khi hi·ªÉn th·ªã)
    for c in ("m1","m3","m6"):
        if c in view.columns:
            view[c] = view[c].apply(pct_return)

    # % metrics ƒë√£ chu·∫©n ho√° s·∫µn trong adapter: rev_yoy, roe, eps_yoy, net_margin
    for c in ("rev_yoy","roe","eps_yoy","net_margin"):
        if c in view.columns:
            view[c] = view[c].apply(pct_ready)

    # ADTV - Debug th√¥ng tin
    if "adtv" in view.columns:
        # ƒê·∫øm s·ªë m√£ c√≥ ADTV h·ª£p l·ªá - d√πng adtv_raw n·∫øu c√≥
        adtv_col = "adtv_raw" if "adtv_raw" in view.columns else "adtv"
        valid_adtv = view[adtv_col].apply(lambda x: not pd.isna(x) and x > 0).sum()
        total_stocks = len(view)
        
        # Debug: in ra gi√° tr·ªã ADTV th√¥ tr∆∞·ªõc khi format
        if total_stocks > 0:
            sample_values = view[adtv_col].head(3).tolist()
            sample_symbols = view["symbol"].head(3).tolist()
            st.info(f"üìä Debug ADTV: {valid_adtv}/{total_stocks} m√£ c√≥ d·ªØ li·ªáu. M·∫´u: {list(zip(sample_symbols, sample_values))}")
            
            # In gi√° tr·ªã max ƒë·ªÉ hi·ªÉu scale
            max_val = view[adtv_col].max()
            min_val = view[adtv_col].min()
            st.info(f"üîç ADTV Range: Min={min_val:.2e}, Max={max_val:.2e}")
        
        # Ki·ªÉm tra kho·∫£ng gi√° tr·ªã ƒë·ªÉ quy·∫øt ƒë·ªãnh ƒë∆°n v·ªã hi·ªÉn th·ªã
        max_adtv = view[adtv_col].max() if not view[adtv_col].empty else 0
        
        if max_adtv > 1e9:  # L·ªõn h∆°n 1 t·ª∑ ‚Üí hi·ªÉn th·ªã theo t·ª∑
            view["adtv"] = view[adtv_col].apply(lambda x: "N/A" if pd.isna(x) or x <= 0 else f"{x/1e9:.1f} t·ª∑")
        elif max_adtv > 1e6:  # L·ªõn h∆°n 1 tri·ªáu ‚Üí hi·ªÉn th·ªã theo tri·ªáu
            view["adtv"] = view[adtv_col].apply(lambda x: "N/A" if pd.isna(x) or x <= 0 else f"{x/1e6:.1f} tr")
        elif max_adtv > 1e3:  # L·ªõn h∆°n 1 ngh√¨n ‚Üí hi·ªÉn th·ªã theo ngh√¨n
            view["adtv"] = view[adtv_col].apply(lambda x: "N/A" if pd.isna(x) or x <= 0 else f"{x/1e3:.1f} k")
        else:  # Nh·ªè h∆°n ‚Üí hi·ªÉn th·ªã nguy√™n gi√° tr·ªã
            view["adtv"] = view[adtv_col].apply(lambda x: "N/A" if pd.isna(x) or x <= 0 else f"{x:.2f}")
        
        # Hi·ªÉn th·ªã th√¥ng tin v·ªÅ ƒë∆°n v·ªã
        if max_adtv > 0:
            if max_adtv > 1e9:
                unit_info = "t·ª∑ VND"
            elif max_adtv > 1e6:
                unit_info = "tri·ªáu VND"  
            elif max_adtv > 1e3:
                unit_info = "ngh√¨n VND"
            else:
                unit_info = "VND (gi√° tr·ªã th√¥ - c√≥ th·ªÉ c·∫ßn fix)"
            st.info(f"üí° ADTV hi·ªÉn th·ªã theo ƒë∆°n v·ªã: {unit_info}. Gi√° tr·ªã max: {max_adtv:,.0f}")
        
        # Hi·ªÉn th·ªã th√¥ng tin debug n·∫øu c·∫ßn
        if valid_adtv < total_stocks:
            st.info(f"üí° Th√¥ng tin: {valid_adtv}/{total_stocks} m√£ c√≥ d·ªØ li·ªáu ADTV. M·ªôt s·ªë m√£ c√≥ th·ªÉ thi·∫øu d·ªØ li·ªáu volume.")

    cols = [c for c in [
        "symbol","score","Value","Quality","Growth","Momentum","Liquidity","RiskAdj",
        "m1","m3","m6","pe","pb","roe","rev_yoy","eps_yoy","net_margin","adtv"
    ] if c in view.columns]

    # ---- Column help / tooltips ----
    col_help = {
        "symbol": "M√£ c·ªï phi·∫øu.",
        "score": "ƒêi·ªÉm t·ªïng h·ª£p theo tr·ªçng s·ªë: Value(0.22), Quality(0.22), Growth(0.20), Momentum(0.20), Liquidity(0.10), Risk(0.06). ƒêi·ªÉm cao = c√¢n b·∫±ng h·∫•p d·∫´n.",
        "Value": "ƒê·ªãnh gi√° t∆∞∆°ng ƒë·ªëi (P/E, P/B). Cao ‚Üí r·∫ª t∆∞∆°ng ƒë·ªëi sau khi so s√°nh v·ªõi nh√≥m ng√†nh/to√†n th·ªã tr∆∞·ªùng",
        "Quality": "Ch·∫•t l∆∞·ª£ng t√†i ch√≠nh (ROE‚Üë, bi√™n r√≤ng‚Üë, D/E‚Üì). Cao ‚Üí ch·∫•t l∆∞·ª£ng t√†i ch√≠nh t·ªët & ƒë√≤n b·∫©y h·ª£p l√Ω.",
        "Growth": "T·ªïng h·ª£p Rev YoY, EPS YoY. Cao t·ªët.",
        "Momentum": "Xu h∆∞·ªõng gi√° (1‚Äì3‚Äì6 th√°ng). D∆∞∆°ng/t·ªët ‚Üí ƒëi·ªÉm cao.",
        "Liquidity": "Thanh kho·∫£n (ADTV). Cao d·ªÖ giao d·ªãch.",
        "RiskAdj": "ƒêi·ªÉm r·ªßi ro ƒëi·ªÅu ch·ªânh theo bi·∫øn ƒë·ªông (vol th·∫•p ƒë∆∞·ª£c c·ªông ƒëi·ªÉm).",
        "m1": "Hi·ªáu su·∫•t ~1 th√°ng (%). D∆∞∆°ng ‚Üí tƒÉng. √Çm ‚Üí gi·∫£m",
        "m3": "Hi·ªáu su·∫•t ~3 th√°ng (%). D∆∞∆°ng ‚Üí tƒÉng. √Çm ‚Üí gi·∫£m",
        "m6": "Hi·ªáu su·∫•t ~6 th√°ng (%). D∆∞∆°ng ‚Üí tƒÉng. √Çm ‚Üí gi·∫£m",
        "pe": "P/E ‚Äî th·∫•p th∆∞·ªùng r·∫ª h∆°n t∆∞∆°ng ƒë·ªëi (xem k√®m Quality/Growth).",
        "pb": "P/B ‚Äî th·∫•p c√≥ th·ªÉ r·∫ª h∆°n t√†i s·∫£n r√≤ng (t√πy ng√†nh).",
        "roe": "ROE (%) ‚Äî T·ª∑ su·∫•t sinh l·ªùi tr√™n v·ªën CSH (ƒë√£ chu·∫©n ho√° th√†nh %). Cao ‚Üí ch·∫•t l∆∞·ª£ng l·ª£i nhu·∫≠n t·ªët.",
        "rev_yoy": "Doanh thu YoY qu√Ω m·ªõi nh·∫•t (%) ‚Äî Cao ‚Üí tƒÉng tr∆∞·ªüng doanh thu t·ªët.",
        "eps_yoy": "TƒÉng tr∆∞·ªüng EPS theo nƒÉm (%) ‚Äî Cao ‚Üí l·ª£i nhu·∫≠n/c·ªï phi·∫øu tƒÉng.",
        "net_margin": "Bi√™n l·ª£i nhu·∫≠n r√≤ng (%). Cao ‚Üí doanh nghi·ªáp gi·ªØ l·∫°i nhi·ªÅu l·ª£i nhu·∫≠n t·ª´ doanh thu.",
        "adtv": "Gi√° tr·ªã giao d·ªãch TB 20 phi√™n (VND). Cao ‚Üí thanh kho·∫£n t·ªët.",
        "sector": "Ng√†nh (d√πng ƒë·ªÉ chu·∫©n ho√° theo ng√†nh).",
    }
    from streamlit import column_config as cc
    column_config = {
        "symbol": cc.TextColumn("M√£ CP", help=col_help["symbol"]),
        "score": cc.TextColumn("ƒêi·ªÉm t·ªïng", help=col_help["score"]),
        "Value": cc.TextColumn("ƒê·ªãnh gi√°", help=col_help["Value"]),
        "Quality": cc.TextColumn("Ch·∫•t l∆∞·ª£ng", help=col_help["Quality"]),
        "Growth": cc.TextColumn("TƒÉng tr∆∞·ªüng", help=col_help["Growth"]),
        "Momentum": cc.TextColumn("Xu h∆∞·ªõng", help=col_help["Momentum"]),
        "Liquidity": cc.TextColumn("Thanh kho·∫£n", help=col_help["Liquidity"]),
        "RiskAdj": cc.TextColumn("R·ªßi ro", help=col_help["RiskAdj"]),
        "m1": cc.TextColumn("1 th√°ng (%)", help=col_help["m1"]),
        "m3": cc.TextColumn("3 th√°ng (%)", help=col_help["m3"]),
        "m6": cc.TextColumn("6 th√°ng (%)", help=col_help["m6"]),
        "pe": cc.TextColumn("P/E", help=col_help["pe"]),
        "pb": cc.TextColumn("P/B", help=col_help["pb"]),
        "roe": cc.TextColumn("ROE (%)", help=col_help["roe"]),
        "rev_yoy": cc.TextColumn("DT YoY (%)", help=col_help["rev_yoy"]),
        "eps_yoy": cc.TextColumn("EPS YoY (%)", help=col_help["eps_yoy"]),
        "net_margin": cc.TextColumn("Bi√™n LN (%)", help=col_help["net_margin"]),
        "adtv": cc.TextColumn("GTGD TB", help=col_help["adtv"]),
        "sector": cc.TextColumn("Ng√†nh", help=col_help["sector"]),
    }

    st.dataframe(
        view[cols],
        use_container_width=True,
        height=380,
        column_config=column_config
    )
    st.caption("M·∫πo: Di chu·ªôt v√†o bi·ªÉu t∆∞·ª£ng ‚ìò c·∫°nh ti√™u ƒë·ªÅ c·ªôt ƒë·ªÉ xem ch√∫ th√≠ch nhanh.")

    # Ghi ch√∫ nhanh v·ªÅ Z-Score
    with st.expander("‚ÑπÔ∏è Ghi ch√∫ nhanh v·ªÅ ph∆∞∆°ng ph√°p Z-Score s·ª≠ d·ª•ng trong b·∫£ng"):
        st.markdown(
            """
- **M·ª•c ti√™u**: ƒë∆∞a c√°c th∆∞·ªõc ƒëo kh√°c ƒë∆°n v·ªã (P/E, % tƒÉng tr∆∞·ªüng, ADTV, bi·∫øn ƒë·ªông‚Ä¶) v·ªÅ c√πng thang **chu·∫©n ho√°** ƒë·ªÉ c·ªông/tr·ª´ c√¥ng b·∫±ng.
- **Chu·∫©n ho√° theo ng√†nh** (*sector-neutral*): so s√°nh doanh nghi·ªáp **trong c√πng ng√†nh** tr∆∞·ªõc khi t·ªïng h·ª£p ƒë·ªÉ tr√°nh m√©o do ƒë·∫∑c th√π ng√†nh.
- **K·ªπ thu·∫≠t**:
  - C·∫Øt ƒëu√¥i nh·∫π outlier (*winsorize* 2%); v·ªõi th∆∞·ªõc ƒëo l·ªách ph·∫£i (ADTV, vol) d√πng `log1p`.
  - ƒêi·ªÅn thi·∫øu theo **trung v·ªã ng√†nh**, sau ƒë√≥ **trung v·ªã to√†n th·ªã tr∆∞·ªùng** n·∫øu v·∫´n thi·∫øu.
  - D√πng **robust z-score**: \\( (x - \\text{median}) / (1.4826 \\times \\text{MAD}) \\) ‚Äî b·ªÅn v·ªØng v·ªõi outlier.
  - C√°c ch·ªâ ti√™u ‚Äú**c√†ng th·∫•p c√†ng t·ªët**‚Äù (P/E, P/B, D/E, volatility) ƒë∆∞·ª£c **ƒë·∫£o d·∫•u** ƒë·ªÉ ƒëi·ªÉm cao = t·ªët.
- **Gi·∫£i th√≠ch ƒëi·ªÉm**:
  - Z ‚âà **0**: ngang trung v·ªã nh√≥m so s√°nh; **+1**: t·ªët h∆°n ƒë√°ng k·ªÉ; **‚àí1**: k√©m h∆°n ƒë√°ng k·ªÉ.
  - **score** = t·ªïng h·ª£p c√≥ tr·ªçng s·ªë: **Value(0.22)**, **Quality(0.22)**, **Growth(0.20)**, **Momentum(0.20)**, **Liquidity(0.10)**, **Risk(0.06)**.
            """
        )

    # ---- K·∫øt lu·∫≠n ----
    st.subheader("‚úÖ K·∫øt lu·∫≠n (Top pick)")
    if ranked.empty:
        st.warning("Kh√¥ng c√≥ m√£ v∆∞·ª£t ng∆∞·ª°ng thanh kho·∫£n ho·∫∑c ƒë·ªß d·ªØ li·ªáu.")
    else:
        best = ranked.iloc[0]
        reasons = []
        for comp in ("Value","Quality","Growth","Momentum","Liquidity","RiskAdj"):
            val = best.get(comp, np.nan)
            if not pd.isna(val):
                reasons.append(f"{comp}={float(val):.2f}")
        sec = best.get("sector", "") or ""
        sec_txt = f" ¬∑ Sector: {sec}" if sec else ""
        st.success(f"**{best['symbol']}** l√† m√£ ph√π h·ª£p nh·∫•t{sec_txt}. L√Ω do: " + "; ".join(reasons))

    if show_charts and not ranked.empty:
        st.subheader("üìä Bi·ªÉu ƒë·ªì & b·∫£ng l·ªãch s·ª≠ (ch·ªçn m√£)")

        top_syms = list(ranked["symbol"].head(min(10, len(ranked))))
        if "selected_symbol" not in st.session_state:
            st.session_state["selected_symbol"] = top_syms[0]

        selected_from_top = st.radio(
            "Top 10 theo ƒëi·ªÉm:",
            options=top_syms,
            index=top_syms.index(st.session_state["selected_symbol"]) if st.session_state["selected_symbol"] in top_syms else 0,
            horizontal=True,
            key="sym_radio",
            help="Ch·ªçn nhanh m·ªôt m√£ trong Top 10 theo ƒëi·ªÉm."
        )
        st.session_state["selected_symbol"] = selected_from_top

        def _on_enter_symbol():
            s = st.session_state.get("manual_symbol_input", "").strip().upper()
            if s:
                st.session_state["selected_symbol"] = s

        st.text_input("Ho·∫∑c nh·∫≠p m√£ kh√°c r·ªìi nh·∫•n Enter:", value="", placeholder="V√≠ d·ª•: FPT",
                      key="manual_symbol_input", on_change=_on_enter_symbol)

        selected_symbol = st.session_state["selected_symbol"]
        px_sel = px_map.get(selected_symbol)
        if (px_sel is None) or px_sel.empty:
            try:
                price_sources = [store["sources"][0]] if store.get("sources") else ["TCBS"]
                px_sel = _get_quote_history_cached(selected_symbol, int(store["params"]["days"]), store["ed_str"], price_sources)
                st.session_state["screener_store"]["px_map"][selected_symbol] = px_sel
            except Exception:
                px_sel = pd.DataFrame()

        chart_title = f"{selected_symbol}"

        if px_sel is None or px_sel.empty:
            st.info("Kh√¥ng c√≥ d·ªØ li·ªáu gi√° ƒë·ªÉ v·∫Ω.")
        else:
            # Th√¥ng tin h∆∞·ªõng d·∫´n s·ª≠ d·ª•ng bi·ªÉu ƒë·ªì
            with st.expander("üí° H∆∞·ªõng d·∫´n t∆∞∆°ng t√°c v·ªõi bi·ªÉu ƒë·ªì", expanded=False):
                st.markdown("""
                **üéØ T√≠nh nƒÉng Auto-scaling tr·ª•c Y:**
                - ‚úÖ Tr·ª•c Y s·∫Ω **t·ª± ƒë·ªông co gi√£n** khi b·∫°n thay ƒë·ªïi kho·∫£ng th·ªùi gian
                - üîç S·ª≠ d·ª•ng c√°c n√∫t **1M, 3M, 6M, All** ƒë·ªÉ thay ƒë·ªïi range nhanh
                - üìä Tr·ª•c Y t·ª± ƒë·ªông t·ªëi ∆∞u hi·ªÉn th·ªã theo gi√° cao nh·∫•t/th·∫•p nh·∫•t trong kho·∫£ng ƒë√£ ch·ªçn
                - üñ±Ô∏è **Double-click** tr√™n bi·ªÉu ƒë·ªì ƒë·ªÉ reset v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu
                
                **üîç T√≠nh nƒÉng Zoom n√¢ng cao:**
                - üñ±Ô∏è **Cu·ªôn chu·ªôt** ƒë·ªÉ zoom in/out tr·ª±c ti·∫øp tr√™n bi·ªÉu ƒë·ªì
                - ‚ö° K√©o th·∫£ ƒë·ªÉ zoom v√πng c·ª• th·ªÉ
                - üìè S·ª≠ d·ª•ng range slider ·ªü d∆∞·ªõi ƒë·ªÉ ƒëi·ªÅu h∆∞·ªõng nhanh
                - üéõÔ∏è C√≥ th·ªÉ nh·∫≠p range tr·ª±c ti·∫øp v√†o c√°c √¥ input
                
                **üìà T∆∞∆°ng t√°c kh√°c:**
                - Hover ƒë·ªÉ xem th√¥ng tin chi ti·∫øt t·∫°i t·ª´ng ƒëi·ªÉm
                - Click v√†o legend ƒë·ªÉ ·∫©n/hi·ªán c√°c ƒë∆∞·ªùng k·ªπ thu·∫≠t
                - K√©o tr·ª•c ƒë·ªÉ pan (di chuy·ªÉn) bi·ªÉu ƒë·ªì
                """)

            fig = make_ohlcv_figure(
                px_sel, chart_title,
                default_months_view=3, right_pad_months=2, height=700,
                show_ma9=show_ma9, show_ma20=show_ma20, show_ma50=show_ma50, 
                show_ma200=show_ma200, show_bollinger=show_bollinger
            )
            
            # C·∫•u h√¨nh plotly ƒë·ªÉ c√≥ th·ªÉ t∆∞∆°ng t√°c t·ªët h∆°n
            plotly_config = {
                "displaylogo": False,
                "modeBarButtonsToRemove": ["lasso2d", "select2d", "autoScale2d"],
                "modeBarButtonsToAdd": ["resetScale2d"],
                "showTips": True,
                "displayModeBar": True,
                "responsive": True,
                "doubleClick": "reset+autosize",  # Double click ƒë·ªÉ reset v·ªÅ auto-scale
                "scrollZoom": True,  # B·∫≠t zoom b·∫±ng cu·ªôn chu·ªôt
                "showAxisDragHandles": True,  # Hi·ªÉn th·ªã handles ƒë·ªÉ k√©o tr·ª•c
                "showAxisRangeEntryBoxes": True  # Hi·ªÉn th·ªã box ƒë·ªÉ nh·∫≠p range tr·ª±c ti·∫øp
            }
            
            st.plotly_chart(fig, use_container_width=True, config=plotly_config)

            st.markdown("**üìú L·ªãch s·ª≠ gi√° (g·∫ßn nh·∫•t)**")
            
            # Format d·ªØ li·ªáu ƒë·ªÉ hi·ªÉn th·ªã ƒë·∫πp
            px_display = px_sel.sort_values("date", ascending=False).head(120).copy()
            
            # Format ng√†y theo ki·ªÉu dd/mm/yyyy
            if "date" in px_display.columns:
                px_display["date"] = pd.to_datetime(px_display["date"]).dt.strftime("%d/%m/%Y")
            
            # Format volume v·ªõi d·∫•u ph·∫©y ngƒÉn c√°ch h√†ng ngh√¨n
            if "volume" in px_display.columns:
                px_display["volume"] = px_display["volume"].apply(
                    lambda x: f"{int(x):,}" if pd.notna(x) and x > 0 else "0"
                )
            
            # Format c√°c c·ªôt gi√° v·ªõi 2 ch·ªØ s·ªë th·∫≠p ph√¢n
            price_cols = ["open", "high", "low", "close"]
            for col in price_cols:
                if col in px_display.columns:
                    px_display[col] = px_display[col].apply(
                        lambda x: f"{float(x):,.2f}" if pd.notna(x) else "N/A"
                    )
            
            # Format gi√° tr·ªã giao d·ªãch n·∫øu c√≥
            if "value" in px_display.columns:
                px_display["value"] = px_display["value"].apply(
                    lambda x: f"{int(x):,}" if pd.notna(x) and x > 0 else "0"
                )
            
            # Column config cho b·∫£ng l·ªãch s·ª≠ gi√°
            price_column_config = {
                "date": cc.TextColumn("Ng√†y"),
                "open": cc.TextColumn("M·ªü c·ª≠a"),
                "high": cc.TextColumn("Cao nh·∫•t"),
                "low": cc.TextColumn("Th·∫•p nh·∫•t"),
                "close": cc.TextColumn("ƒê√≥ng c·ª≠a"),
                "volume": cc.TextColumn("Kh·ªëi l∆∞·ª£ng"),
                "value": cc.TextColumn("Gi√° tr·ªã")
            }
            st.dataframe(px_display, use_container_width=True, height=320, column_config=price_column_config)

            # ====== üìÑ B√°o c√°o theo FORM k·ªπ thu·∫≠t (MA20/50/200) ======
            st.markdown("---")
            st.markdown("### üìÑ B√°o c√°o theo form k·ªπ thu·∫≠t (MA20/50/200)")
            tech_stats = build_structured_stats(px_sel)

            c1, c2 = st.columns([1, 3])
            with c1:
                btn_form = st.button("T·∫°o b√°o c√°o theo form", key=f"form_btn_{selected_symbol}")
            with c2:
                st.caption("Xu·∫•t ƒë√∫ng m·∫´u b·∫°n g·ª≠i, d·ª±a tr√™n gi√° & kh·ªëi l∆∞·ª£ng hi·ªán c√≥ (RSI/ATR/52W/MA20/50/200).")

            if btn_form:
                key = st.session_state.get("openai_api_key", "") or ""
                model = llm_model or "gpt-4o-mini"
                report = call_llm_structured_report(key, model, selected_symbol, tech_stats)
                st.session_state.setdefault("form_cache", {})[selected_symbol] = report

            form_text = (st.session_state.get("form_cache") or {}).get(selected_symbol)
            if form_text:
                st.markdown(form_text)
                st.download_button(
                    label="‚¨áÔ∏è T·∫£i b√°o c√°o (.txt)",
                    data="\ufeff" + form_text,
                    file_name=f"{selected_symbol}_PTKT_{store['ed_str']}.txt",
                    mime="text/plain; charset=utf-8"
                )

            # ====== üì∞ C√¥ng b·ªë/ho·∫°t ƒë·ªông 7 ng√†y g·∫ßn ƒë√¢y (TCBS) ======
            st.markdown("### üì∞ C√¥ng b·ªë trong 7 ng√†y g·∫ßn ƒë√¢y (TCBS)")
            raw = fetch_activity_news_raw(selected_symbol, size=100)
            recent_items = filter_recent_activity_news(raw, recent_days=7)
            if not recent_items:
                st.markdown("_Kh√¥ng th·∫•y c√¥ng b·ªë trong 7 ng√†y g·∫ßn ƒë√¢y_")
            else:
                for it in recent_items:
                    ts_str = it["published_at"].strftime("%Y-%m-%d %H:%M")
                    src = it.get("source") or ""
                    title = it["title"]
                    st.markdown(f"- {ts_str} ¬∑ {src} ‚Äî {title}")

# ===== FOOTER =====
st.caption("(*) C√¥ng c·ª• s√†ng l·ªçc ƒë·ªãnh l∆∞·ª£ng mang t√≠nh tham kh·∫£o. Kh√¥ng ph·∫£i khuy·∫øn ngh·ªã ƒë·∫ßu t∆∞. K·∫øt h·ª£p th√™m ph√¢n t√≠ch ng√†nh, catalyst v√† qu·∫£n tr·ªã r·ªßi ro.")
